<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vuex和pinia</title>
    <link href="/2024/11/15/Interview/vue/vuex%E5%92%8Cpinia/"/>
    <url>/2024/11/15/Interview/vue/vuex%E5%92%8Cpinia/</url>
    
    <content type="html"><![CDATA[<h2 id="Vuex-作为-Vue-js-的状态管理库，其核心思想是“单向数据流”和“状态变更必须是可追踪的”。为了实现这一点，Vuex-使用了严格的分离："><a href="#Vuex-作为-Vue-js-的状态管理库，其核心思想是“单向数据流”和“状态变更必须是可追踪的”。为了实现这一点，Vuex-使用了严格的分离：" class="headerlink" title="Vuex 作为 Vue.js 的状态管理库，其核心思想是“单向数据流”和“状态变更必须是可追踪的”。为了实现这一点，Vuex 使用了严格的分离："></a>Vuex 作为 Vue.js 的状态管理库，其核心思想是“单向数据流”和“状态变更必须是可追踪的”。为了实现这一点，Vuex 使用了严格的分离：</h2><ol><li><p><strong><code>mutation</code></strong>:</p><ul><li><strong>用途</strong>：负责同步修改 state（状态）。所有对 state 的修改必须通过 <code>mutation</code> 来进行，确保状态变化的可追踪性。</li><li><strong>原则</strong>：由于它是同步的，所有的状态变化都会立刻反映到应用的视图上。</li><li><strong>设计</strong>：你不能在 <code>mutation</code> 中做异步操作，这确保了在 Vuex 中，状态更新是可预测的。</li><li><strong>好处</strong>：<ul><li><strong>可追踪性</strong>：你可以追踪每个状态的变更，尤其是在调试时非常方便。工具如 Vue DevTools 可以帮助你查看每一次状态变化，甚至回溯到哪个 <code>mutation</code> 触发了该变化。</li><li><strong>严格的同步</strong>：同步状态变化意味着不会有状态变更时机的不确定性，增加了代码的稳定性。</li></ul></li></ul></li><li><p><strong><code>action</code></strong>:</p><ul><li><strong>用途</strong>：负责处理异步操作或其他复杂逻辑，最终可以调用 <code>mutation</code> 来修改 state。</li><li><strong>原则</strong>：<code>action</code> 是异步的，你可以在其中进行 API 请求、定时器、或其他异步操作，操作完成后通过 <code>mutation</code> 更新 state。</li><li><strong>设计</strong>：<code>action</code> 允许在处理异步逻辑时，有机会进行中间处理或多步操作。</li><li><strong>好处</strong>：<ul><li><strong>处理复杂逻辑</strong>：你可以在 <code>action</code> 中处理异步请求（如 fetch 或 axios 调用），并且操作完后进行状态更新，保证应用的响应性。</li></ul></li></ul></li></ol><p><strong>总结</strong>：在 Vuex 中，<code>mutation</code> 和 <code>action</code> 的分离可以清晰地将同步和异步逻辑区分开来，尤其在大型应用中，维护性和可调试性更强。</p><hr><h2 id="Pinia-的设计理念：合并-mutation-和-action"><a href="#Pinia-的设计理念：合并-mutation-和-action" class="headerlink" title="Pinia 的设计理念：合并 mutation 和 action"></a><strong>Pinia 的设计理念：合并 <code>mutation</code> 和 <code>action</code></strong></h2><p>Pinia 是 Vue 3 推出的新的状态管理库，相较于 Vuex，它进行了简化设计，采用了更现代的 API 和更小的学习曲线。一个显著的改变是：Pinia 只使用 <code>action</code> 来处理状态的修改，无论是同步还是异步操作。</p><ol><li><p><strong><code>state</code></strong>:</p><ul><li>Pinia 中的 <code>state</code> 直接定义了响应式数据，和 Vuex 中的 <code>state</code> 类似。</li></ul></li><li><p><strong><code>actions</code></strong>:</p><ul><li>在 Pinia 中，<code>actions</code> 被用来处理同步和异步操作。你不再需要分别定义 <code>mutation</code> 和 <code>action</code>。</li><li>在 <code>action</code> 中直接修改 <code>state</code>，即使这些操作是同步的，也不需要通过 <code>mutation</code> 来包装。</li><li><code>actions</code> 可以同时处理同步逻辑和异步操作，允许在其中直接改变状态。</li></ul></li></ol><p><strong>优点</strong>：</p><ul><li><strong>简洁性</strong>：没有 <code>mutation</code> 的概念，简化了代码。你不需要再为每个状态的修改写单独的 <code>mutation</code>，大大减少了样板代码（boilerplate code）。</li><li><strong>更少的冗余</strong>：状态修改逻辑可以在 <code>actions</code> 中完成，不再需要通过 <code>mutation</code> 来单独封装同步更新，操作更加直观。</li><li><strong>更灵活的 API</strong>：由于 <code>actions</code> 中既可以处理同步操作，也可以处理异步操作，逻辑组织上变得更加灵活和方便。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>状态更新不明确</strong>：由于同步和异步操作都可以直接在 <code>action</code> 中修改 <code>state</code>，这可能导致状态更新的来源不如 Vuex 那样直观。在调试时，开发者无法直接知道哪些操作是同步的，哪些是异步的，可能会造成调试上的一些困惑。</li><li><strong>调试难度</strong>：在 Vuex 中，你可以很明确地看到是哪个 <code>mutation</code> 更新了状态，而 Pinia 中状态更新往往不明确，可能不如 Vuex 的调试工具直观。</li><li><strong>潜在的副作用</strong>：由于 <code>actions</code> 没有严格区分同步和异步操作，可能会导致某些情况下，状态变更的时机不如预期（特别是在组件渲染时）。</li></ul><hr><h2 id="Vuex-vs-Pinia：优缺点对比"><a href="#Vuex-vs-Pinia：优缺点对比" class="headerlink" title="Vuex vs Pinia：优缺点对比"></a><strong>Vuex vs Pinia：优缺点对比</strong></h2><table><thead><tr><th>特性</th><th>Vuex</th><th>Pinia</th></tr></thead><tbody><tr><td><strong>状态管理</strong></td><td><code>mutation</code> 和 <code>action</code> 分离，<code>mutation</code> 只负责同步修改 state</td><td><code>actions</code> 处理同步和异步操作，简化代码结构</td></tr><tr><td><strong>可预测性</strong></td><td>更高，因同步操作严格限制在 <code>mutation</code> 中</td><td>可能较低，因为 <code>actions</code> 同时处理同步和异步操作</td></tr><tr><td><strong>学习曲线</strong></td><td>较陡峭，需要理解 <code>mutation</code> 和 <code>action</code> 的区别</td><td>较低，合并了 <code>mutation</code> 和 <code>action</code>，更简单</td></tr><tr><td><strong>代码冗余</strong></td><td>更多样板代码，尤其是在状态修改时需要分别写 <code>mutation</code></td><td>减少样板代码，逻辑更紧凑</td></tr><tr><td><strong>调试能力</strong></td><td>调试时可以准确知道是哪一个 <code>mutation</code> 更新了状态</td><td>调试时状态更新的来源不太明确，可能较为模糊</td></tr><tr><td><strong>灵活性</strong></td><td>高，适用于大型项目，有明确的同步&#x2F;异步逻辑区分</td><td>简单直接，适合中小型项目，逻辑清晰</td></tr></tbody></table><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li><strong>Vuex</strong> 适用于大型、复杂的应用，尤其当你需要严格的同步&#x2F;异步操作区分时，它提供了更好的调试和可追踪性。它的设计哲学强调状态的变更应该是明确且可预测的，因此会稍显繁琐，需要维护更多的 <code>mutation</code> 和 <code>action</code> 逻辑。</li><li><strong>Pinia</strong> 更简洁且灵活，适用于中小型项目，它减少了状态管理的复杂度，并且允许你在一个 <code>action</code> 中同时处理同步和异步操作。虽然它提供了更轻量的 API，但也牺牲了部分的可追踪性，尤其在复杂应用中可能会导致调试上的困难。</li></ul><p>如果你的项目是简单或者中等规模的，并且你希望减少样板代码，Pinia 是一个很好的选择；如果你的项目较大且需要更高的可维护性和可调试性，Vuex 可能更合适。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue2</tag>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pinia不共享状态(闭包思想)</title>
    <link href="/2024/11/13/Interview/vue/pinia%E4%B8%8D%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81(%E9%97%AD%E5%8C%85%E6%80%9D%E6%83%B3)/"/>
    <url>/2024/11/13/Interview/vue/pinia%E4%B8%8D%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81(%E9%97%AD%E5%8C%85%E6%80%9D%E6%83%B3)/</url>
    
    <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>面试时，面试官问了我一个感觉比较有意思的问题，抽空来记录下。</p><h2 id="具体问题"><a href="#具体问题" class="headerlink" title="具体问题"></a>具体问题</h2><p>Pinia 是 Vue 的专属状态管理库，它允许你跨组件或页面共享状态。那如果想使用pinia实现单独的状态应该怎么做。</p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>这道题和vue中data的用法很像，因为data可以使用方法形式定义也可以使用对象形式，可以先分析下vue的data定义再来解决这个问题<br>先模仿组件构造函数，定义 <code>data</code>属性，采用对象的形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params"></span>)&#123;<br> <br>&#125;<br><span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">data</span> = &#123;<br>count : <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>创建两个组件实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> componentA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Component</span>()<br><span class="hljs-keyword">const</span> componentB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Component</span>()<br></code></pre></td></tr></table></figure><p>修改 <code>componentA</code>组件 <code>data</code>属性的值，<code>componentB</code>中的值也发生了改变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(componentB.<span class="hljs-property">data</span>.<span class="hljs-property">count</span>)  <span class="hljs-comment">// 0</span><br>componentA.<span class="hljs-property">data</span>.<span class="hljs-property">count</span> = <span class="hljs-number">1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(componentB.<span class="hljs-property">data</span>.<span class="hljs-property">count</span>)  <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>产生这样的原因这是两者共用了同一个内存地址，<code>componentA</code>修改的内容，同样对 <code>componentB</code>产生了影响<br>运用闭包思想的话就可以解决这个问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">data</span>()<br>&#125;<br><span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">data</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>   count : <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改 <code>componentA</code>组件 <code>data</code>属性的值，<code>componentB</code>中的值不受影响</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(componentB.<span class="hljs-property">data</span>.<span class="hljs-property">count</span>)  <span class="hljs-comment">// 0</span><br>componentA.<span class="hljs-property">data</span>.<span class="hljs-property">count</span> = <span class="hljs-number">1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(componentB.<span class="hljs-property">data</span>.<span class="hljs-property">count</span>)  <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>现在就很明显了，其实data之所以能做到各个使用的地方互不影响，是因为运用了闭包思想，pinia的那个问题也可以使用闭包思想解决</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue2</tag>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue2和vue3key的作用</title>
    <link href="/2024/11/12/Interview/vue/vue2%E5%92%8Cvue3key%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2024/11/12/Interview/vue/vue2%E5%92%8Cvue3key%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>在 Vue 2 和 Vue 3 中，<code>key</code> 的作用是确保 Vue 在渲染和更新时能够高效地进行组件或 DOM 元素的复用、重排和渲染优化。尽管 Vue 2 和 Vue 3 在很多方面有相似之处，<code>key</code> 的基本作用一致，但两者在底层的实现和优化上存在一些区别。</p><h1 id="1-key-的作用（Vue-2-和-Vue-3）"><a href="#1-key-的作用（Vue-2-和-Vue-3）" class="headerlink" title="1. key 的作用（Vue 2 和 Vue 3）"></a>1. <strong><code>key</code> 的作用（Vue 2 和 Vue 3）</strong></h1><h2 id="主要作用："><a href="#主要作用：" class="headerlink" title="主要作用："></a>主要作用：</h2><ul><li><strong>标识唯一性：</strong> <code>key</code> 用来标识每个组件或 DOM 元素的唯一性，确保 Vue 在虚拟 DOM 比对时能够正确区分不同的组件或元素。</li><li><strong>优化更新：</strong> 当组件列表或 DOM 元素发生变化时，<code>key</code> 帮助 Vue 高效地进行更新，避免不必要的销毁和重建操作。Vue 通过 <code>key</code> 来确保只更新有变化的部分，复用其他没有变化的部分。</li></ul><h2 id="典型场景："><a href="#典型场景：" class="headerlink" title="典型场景："></a>典型场景：</h2><ul><li><strong>列表渲染：</strong> 在使用 <code>v-for</code> 渲染列表时，<code>key</code> 确保列表项的唯一性。这样 Vue 在更新时能够智能地复用现有的 DOM 元素，而不是重新渲染整个列表。</li><li><strong>动态组件：</strong> 在切换不同的组件时，<code>key</code> 可以帮助 Vue 精确地识别和复用组件，而不会重复销毁和创建组件。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><br>    &#123;&#123; item.name &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>key</code> 帮助 Vue 确保每个 <code>div</code> 的唯一性，从而在数据更新时能够正确地复用 DOM 元素。</p><h1 id="2-Vue-2-中的-key"><a href="#2-Vue-2-中的-key" class="headerlink" title="2. Vue 2 中的 key"></a>2. <strong>Vue 2 中的 <code>key</code></strong></h1><h2 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h2><ul><li><strong>全量对比：</strong> 在 Vue 2 中，当更新时 Vue 会对比当前和旧的虚拟 DOM。<code>key</code> 的作用是帮助 Vue 跟踪列表项或组件，避免不必要的销毁和重建，但 Vue 2 的 diff 算法会进行 <strong>全量对比</strong>，即使 <code>key</code> 一致，也可能会对整个列表进行比较和重排。</li><li><strong>列表重排：</strong> 如果列表的顺序发生变化，Vue 2 会检查 <code>key</code>，然后尝试对已有的元素进行重新排列，而不是重新渲染整个列表。</li></ul><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><ul><li><strong>全量更新：</strong> 当列表中的元素顺序发生变化时，Vue 2 可能会进行较为广泛的更新和重排。Vue 会重新渲染每个组件，即使它们的 <code>key</code> 相同，尤其是对于较复杂的组件或较长的列表，性能可能会受到影响。</li></ul><h1 id="3-Vue-3-中的-key"><a href="#3-Vue-3-中的-key" class="headerlink" title="3. Vue 3 中的 key"></a>3. <strong>Vue 3 中的 <code>key</code></strong></h1><h2 id="工作原理：-1"><a href="#工作原理：-1" class="headerlink" title="工作原理："></a>工作原理：</h2><ul><li><p><strong>优化的 diff 算法：</strong> Vue 3 引入了更高效的虚拟 DOM 和 diff 算法，<code>key</code> 的作用依旧是确保元素的唯一性和更新优化，但 Vue 3 在底层做了更多的性能优化，使得它能够更加智能地处理更新，尤其是在列表和动态组件的渲染时。</p></li><li><p><strong>片段更新：</strong> Vue 3 在渲染时支持更加高效的 <strong>块级更新</strong> 和 <strong>片段更新</strong>，它能够避免不必要的全量对比，而是通过局部更新来减少 DOM 操作。这意味着，尽管 <code>key</code> 保持一致，Vue 3 会更智能地判断哪些部分需要更新，哪些可以复用。</p></li><li><p><strong>列表渲染优化：</strong> 对于大规模的动态列表，Vue 3 会尽量减少重新渲染的元素，仅重排有变化的元素，且避免对没有变化的元素进行更新。</p></li></ul><h2 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h2><ul><li><strong>性能提升：</strong> 通过优化虚拟 DOM diff 算法和更新策略，Vue 3 在性能上有显著提升，特别是在列表排序、动态组件等场景下，Vue 3 对 <code>key</code> 的使用可以更加精细地控制更新，避免了 Vue 2 中的全量更新。</li></ul><h1 id="4-Vue-2-和-Vue-3-中-key-的区别"><a href="#4-Vue-2-和-Vue-3-中-key-的区别" class="headerlink" title="4. Vue 2 和 Vue 3 中 key 的区别"></a>4. <strong>Vue 2 和 Vue 3 中 <code>key</code> 的区别</strong></h1><table><thead><tr><th>特性</th><th>Vue 2</th><th>Vue 3</th></tr></thead><tbody><tr><td><strong>Diff 算法</strong></td><td>全量对比（不够精细）</td><td>优化的虚拟 DOM 和差异化更新</td></tr><tr><td><strong>列表渲染性能</strong></td><td>相对较差，复杂的更新会进行全量渲染</td><td>更高效，能够局部更新、优化排序操作</td></tr><tr><td><strong>组件更新效率</strong></td><td>如果 <code>key</code> 不同，会销毁并重建组件</td><td>使用 <code>key</code> 后，组件复用更智能、细粒度</td></tr><tr><td><strong>更新时的 DOM 操作</strong></td><td>会做较多的 DOM 操作和重排</td><td>更少的 DOM 操作，更新更高效</td></tr><tr><td><strong>动态组件支持</strong></td><td>支持动态组件，但性能较为有限</td><td>动态组件的更新更高效，支持更复杂的场景</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><strong>Vue 2</strong> 和 <strong>Vue 3</strong> 中，<code>key</code> 的作用是相同的，都是为了确保组件和 DOM 元素的唯一性，优化列表渲染和组件的复用。</li><li><strong>Vue 2</strong> 采用了全量对比的 diff 算法，在一些情况下会导致性能问题，特别是在列表渲染时。</li><li><strong>Vue 3</strong> 在这方面做了显著优化，通过更高效的虚拟 DOM 和 diff 算法，能够实现更加精细的更新，减少不必要的 DOM 操作，提高性能。</li></ul><p>因此，在 Vue 3 中，<code>key</code> 的使用依然非常重要，但得益于底层优化，Vue 3 在处理更新时能更高效地复用组件，减少重渲染，从而提升了性能。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue2</tag>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue2和vue3Diff算法</title>
    <link href="/2024/11/12/Interview/vue/vue2%E5%92%8Cvue3Diff%E7%AE%97%E6%B3%95/"/>
    <url>/2024/11/12/Interview/vue/vue2%E5%92%8Cvue3Diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h3><ul><li><strong>双端比较</strong>：使用双端（头尾）比较的方法，设置指针分别指向新旧节点列表的开始和结束，依次比较节点，寻找可复用的节点。</li><li><strong>暴力更新</strong>：当新旧节点不匹配时，Vue2 可能会进行全量更新，即使是小的变化也可能导致整个子树的重新渲染。</li></ul><h3 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h3><ul><li><strong>优化的快速 diff 算法</strong>：引入了更高效的 diff 算法，通过创建一个映射表来记录新旧节点的位置，并利用最长递增子序列（LIS）算法来优化节点的移动。</li><li><strong>静态节点处理</strong>：对静态节点进行特殊处理，避免对这些节点进行不必要的比较，从而进一步提升性能。</li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="Vue2-1"><a href="#Vue2-1" class="headerlink" title="Vue2"></a>Vue2</h3><ul><li><strong>时间复杂度</strong>：在最坏情况下，时间复杂度为 O(n³)，这在大型应用中可能导致性能瓶颈。</li><li><strong>优化策略</strong>：虽然有一些优化策略（如头尾对比、交叉对比），但整体上仍然依赖于较多的遍历和比较操作。</li></ul><h3 id="Vue3-1"><a href="#Vue3-1" class="headerlink" title="Vue3"></a>Vue3</h3><ul><li><strong>时间复杂度降低</strong>：通过引入映射表和 LIS 算法，Vue3 的 diff 算法将时间复杂度降低到 𝑂(𝑛)，使得在处理大量节点时更加高效。</li><li><strong>更少的 DOM 操作</strong>：由于能够更好地复用现有节点，Vue3 在更新视图时减少了对 DOM 的直接操作，这不仅提高了性能，也改善了用户体验。</li></ul><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="Vue2-2"><a href="#Vue2-2" class="headerlink" title="Vue2"></a>Vue2</h3><ul><li>使用 <code>updateChildren</code> 函数进行子节点的比较和更新，通过循环遍历所有子节点来寻找差异。</li><li>在处理数组时，使用双指针从头部和尾部同时向中间遍历，以寻找可复用的节点。</li></ul><h3 id="Vue3-2"><a href="#Vue3-2" class="headerlink" title="Vue3"></a>Vue3</h3><ul><li>引入了 <code>isSameVNodeType</code> 函数来判断两个虚拟节点是否相同，并在此基础上进行更细粒度的更新操作。</li><li>通过映射表快速查找旧节点的位置，大幅提升了查找效率，并使用 LIS 算法来确定哪些节点可以原地复用。</li></ul><h2 id="具体步骤对比"><a href="#具体步骤对比" class="headerlink" title="具体步骤对比"></a>具体步骤对比</h2><h3 id="Vue2-的-Diff-流程"><a href="#Vue2-的-Diff-流程" class="headerlink" title="Vue2 的 Diff 流程"></a>Vue2 的 Diff 流程</h3><ol><li><strong>初始化指针</strong>：设置四个指针（<code>oldStartIdx</code>, <code>oldEndIdx</code>, <code>newStartIdx</code>, <code>newEndIdx</code>）指向新旧 VNode 列表。</li><li><strong>首尾比较</strong>：从前往后和从后往前同时比较，找到相同的节点并进行 patch。</li><li><strong>交叉比较</strong>：如果未找到匹配项，则交叉比较。</li><li><strong>新增和删除</strong>：处理剩余的新旧节点，进行新增或删除操作。</li></ol><h3 id="Vue3-的-Diff-流程"><a href="#Vue3-的-Diff-流程" class="headerlink" title="Vue3 的 Diff 流程"></a>Vue3 的 Diff 流程</h3><ol><li><strong>前置和后置处理</strong>：首先处理前置和后置相同的节点。</li><li><strong>构建映射表</strong>：创建一个映射表记录新 VNode 在旧 VNode 中的位置索引。</li><li><strong>计算最长递增子序列（LIS）</strong>：利用 LIS 确定哪些新节点可以原地复用。</li><li><strong>移动和插入操作</strong>：根据 LIS 和映射表进行 DOM 的移动和插入。</li></ol><h2 id="代码demo"><a href="#代码demo" class="headerlink" title="代码demo"></a>代码demo</h2><h3 id="示例场景"><a href="#示例场景" class="headerlink" title="示例场景"></a>示例场景</h3><p>我们将创建一个简单的列表组件，初始渲染的列表如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>   <br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当我们更新这个列表，新的列表变为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>   <br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>Item 4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这个更新中，我们删除了 <code>Item 1</code>，添加了 <code>Item 4</code>，并保持了 <code>Item 2</code> 和 <code>Item 3</code>。</p><h3 id="Vue2-Diff-算法实现"><a href="#Vue2-Diff-算法实现" class="headerlink" title="Vue2 Diff 算法实现"></a>Vue2 Diff 算法实现</h3><p>以下是 Vue2 的 diff 算法的简化实现，主要通过双端比较来处理节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sameVNode</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-property">key</span> === b.<span class="hljs-property">key</span>; <span class="hljs-comment">// 比较节点的 key</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">oldVnode, vnode</span>) &#123;<br>    <span class="hljs-comment">// 如果节点相同，直接复用</span><br>    <span class="hljs-keyword">if</span> (oldVnode === vnode) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 更新节点属性（省略具体实现）</span><br>    <span class="hljs-comment">// updateProps(oldVnode, vnode);</span><br><br>    <span class="hljs-keyword">const</span> oldCh = oldVnode.<span class="hljs-property">children</span> || [];<br>    <span class="hljs-keyword">const</span> newCh = vnode.<span class="hljs-property">children</span> || [];<br><br>    <span class="hljs-title function_">updateChildren</span>(oldVnode.<span class="hljs-property">elm</span>, oldCh, newCh);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateChildren</span>(<span class="hljs-params">parentElm, oldCh, newCh</span>) &#123;<br>    <span class="hljs-keyword">let</span> oldStartIdx = <span class="hljs-number">0</span>, oldEndIdx = oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> newStartIdx = <span class="hljs-number">0</span>, newEndIdx = newCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVNode</span>(oldCh[oldStartIdx], newCh[newStartIdx])) &#123;<br>            <span class="hljs-title function_">patch</span>(oldCh[oldStartIdx], newCh[newStartIdx]);<br>            oldStartIdx++;<br>            newStartIdx++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVNode</span>(oldCh[oldEndIdx], newCh[newEndIdx])) &#123;<br>            <span class="hljs-title function_">patch</span>(oldCh[oldEndIdx], newCh[newEndIdx]);<br>            oldEndIdx--;<br>            newEndIdx--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 停止比较</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 新增节点</span><br>    <span class="hljs-keyword">if</span> (newStartIdx &lt;= newEndIdx) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = newStartIdx; i &lt;= newEndIdx; i++) &#123;<br>            <span class="hljs-title function_">addVnode</span>(parentElm, newCh[i]); <span class="hljs-comment">// 添加新节点</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除节点</span><br>    <span class="hljs-keyword">if</span> (oldStartIdx &lt;= oldEndIdx) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = oldStartIdx; i &lt;= oldEndIdx; i++) &#123;<br>            <span class="hljs-title function_">removeVnode</span>(parentElm, oldCh[i]); <span class="hljs-comment">// 删除旧节点</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addVnode</span>(<span class="hljs-params">parentElm, vnode</span>) &#123;<br>    <span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br>    el.<span class="hljs-property">textContent</span> = vnode.<span class="hljs-property">text</span>;<br>    parentElm.<span class="hljs-title function_">appendChild</span>(el);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeVnode</span>(<span class="hljs-params">parentElm, vnode</span>) &#123;<br>    <span class="hljs-keyword">const</span> el = parentElm.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">`li[key=&quot;<span class="hljs-subst">$&#123;vnode.key&#125;</span>&quot;]`</span>);<br>    <span class="hljs-keyword">if</span> (el) parentElm.<span class="hljs-title function_">removeChild</span>(el);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Vue3-Diff-算法实现"><a href="#Vue3-Diff-算法实现" class="headerlink" title="Vue3 Diff 算法实现"></a>Vue3 Diff 算法实现</h3><p>以下是 Vue3 的 diff 算法的简化实现，主要通过映射表和最长递增子序列（LIS）来优化节点处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isSameVNodeType</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-property">key</span> === b.<span class="hljs-property">key</span>; <span class="hljs-comment">// 比较节点的 key</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">oldVNode, vNode</span>) &#123;<br>    <span class="hljs-keyword">if</span> (oldVNode === vNode) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 更新节点属性（省略具体实现）</span><br>    <br>    <span class="hljs-keyword">const</span> oldChildren = oldVNode.<span class="hljs-property">children</span> || [];<br>    <span class="hljs-keyword">const</span> newChildren = vNode.<span class="hljs-property">children</span> || [];<br><br>    <span class="hljs-title function_">updateChildren</span>(oldVNode.<span class="hljs-property">elm</span>, oldChildren, newChildren);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateChildren</span>(<span class="hljs-params">parentElm, oldCh, newCh</span>) &#123;<br>    <span class="hljs-keyword">let</span> oldStartIdx = <span class="hljs-number">0</span>, oldEndIdx = oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> newStartIdx = <span class="hljs-number">0</span>, newEndIdx = newCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSameVNodeType</span>(oldCh[oldStartIdx], newCh[newStartIdx])) &#123;<br>            <span class="hljs-title function_">patch</span>(oldCh[oldStartIdx], newCh[newStartIdx]);<br>            oldStartIdx++;<br>            newStartIdx++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSameVNodeType</span>(oldCh[oldEndIdx], newCh[newEndIdx])) &#123;<br>            <span class="hljs-title function_">patch</span>(oldCh[oldEndIdx], newCh[newEndIdx]);<br>            oldEndIdx--;<br>            newEndIdx--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 停止比较</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> keyToIndexMap = &#123;&#125;;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = oldStartIdx; i &lt;= oldEndIdx; i++) &#123;<br>        keyToIndexMap[oldCh[i].<span class="hljs-property">key</span>] = i; <span class="hljs-comment">// 构建映射表</span><br>    &#125;<br><br>    <span class="hljs-keyword">const</span> toMove = [];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = newStartIdx; i &lt;= newEndIdx; i++) &#123;<br>        <span class="hljs-keyword">const</span> key = newCh[i].<span class="hljs-property">key</span>;<br>        <span class="hljs-keyword">const</span> moveIndex = keyToIndexMap[key];<br>        <br>        <span class="hljs-keyword">if</span> (moveIndex !== <span class="hljs-literal">undefined</span>) &#123;<br>            toMove.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">index</span>: moveIndex, <span class="hljs-attr">vnode</span>: oldCh[moveIndex] &#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">addVnode</span>(parentElm, newCh[i]); <span class="hljs-comment">// 新增节点</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 使用 LIS 确定移动顺序</span><br>    <span class="hljs-keyword">const</span> lisIndices = <span class="hljs-title function_">calculateLIS</span>(toMove.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">index</span>));<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> index <span class="hljs-keyword">of</span> lisIndices) &#123;<br>        <span class="hljs-title function_">moveNode</span>(parentElm, toMove[index].<span class="hljs-property">vnode</span>); <span class="hljs-comment">// 移动节点到正确位置</span><br>    &#125;<br><br>    <span class="hljs-comment">// 删除多余的旧节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = oldStartIdx; i &lt;= oldEndIdx; i++) &#123;<br>        <span class="hljs-title function_">removeVnode</span>(parentElm, oldCh[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateLIS</span>(<span class="hljs-params">arr</span>) &#123;<br>   <span class="hljs-keyword">const</span> lis = [];<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> arr) &#123;<br>       <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">let</span> right = lis.<span class="hljs-property">length</span>;<br><br>       <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>           <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);<br>           <span class="hljs-keyword">if</span> (lis[mid] &lt; value) left = mid + <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">else</span> right = mid;<br>       &#125;<br><br>       <span class="hljs-keyword">if</span> (left &gt;= lis.<span class="hljs-property">length</span>) lis.<span class="hljs-title function_">push</span>(value);<br>       <span class="hljs-keyword">else</span> lis[left] = value;<br>   &#125;<br>   <span class="hljs-keyword">return</span> lis;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addVnode</span>(<span class="hljs-params">parentElm, vnode</span>) &#123;<br>   <span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br>   el.<span class="hljs-property">textContent</span> = vnode.<span class="hljs-property">text</span>;<br>   parentElm.<span class="hljs-title function_">appendChild</span>(el);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeVnode</span>(<span class="hljs-params">parentElm, vnode</span>) &#123;<br>   <span class="hljs-keyword">const</span> el = parentElm.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">`li[key=&quot;<span class="hljs-subst">$&#123;vnode.key&#125;</span>&quot;]`</span>);<br>   <span class="hljs-keyword">if</span> (el) parentElm.<span class="hljs-title function_">removeChild</span>(el);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">moveNode</span>(<span class="hljs-params">parentElm, vnode</span>) &#123;<br>   <span class="hljs-keyword">const</span> el = parentElm.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">`li[key=&quot;<span class="hljs-subst">$&#123;vnode.key&#125;</span>&quot;]`</span>);<br>   <span class="hljs-keyword">if</span> (el &amp;&amp; el !== parentElm.<span class="hljs-property">lastChild</span>) &#123; <br>       parentElm.<span class="hljs-title function_">appendChild</span>(el); <span class="hljs-comment">// 移动到父元素最后</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue2</tag>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能优化</title>
    <link href="/2024/09/24/Interview/js/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2024/09/24/Interview/js/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>前端优化大概可以有以下几个方向：</p><ul><li>网络优化</li><li>页面渲染优化</li><li>JS优化</li><li>图片优化</li><li>webpack打包优化</li><li>Vue和React优化</li><li>数据埋点及性能监控</li></ul><h1 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h1><h2 id="DNS预解析"><a href="#DNS预解析" class="headerlink" title="DNS预解析"></a>DNS预解析</h2><p>link标签的rel属性设置dns-prefetch，提前获取域名对应的IP地址</p><h2 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a>使用缓存</h2><p>减轻服务端压力，快速得到数据(强缓存和协商缓存)(<a href="https://juejin.cn/post/7178783712363708475#heading-27" title="https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7178783712363708475#heading-27">juejin.cn&#x2F;post&#x2F;717878…</a>))</p><h2 id="使用-CDN（内容分发网络）"><a href="#使用-CDN（内容分发网络）" class="headerlink" title="使用 CDN（内容分发网络）"></a>使用 CDN（内容分发网络）</h2><p>用户与服务器的物理距离对响应时间也有影响。</p><p>内容分发网络（CDN）是一组分散在不同地理位置的 web 服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器。</p><h2 id="压缩响应"><a href="#压缩响应" class="headerlink" title="压缩响应"></a>压缩响应</h2><p>压缩组件通过减少 HTTP 请求产生的响应包的大小，从而降低传输时间的方式来提高性能。从 HTTP1.1 开始，Web 客户端可以通过 HTTP 请求中的 Accept-Encoding 头来标识对压缩的支持（这个请求头会列出一系列的压缩方法）</p><p>如果 Web 服务器看到请求中的这个头，就会使用客户端列出的方法中的一种来压缩响应。Web 服务器通过响应中的 Content-Encoding 头来告知 Web 客户端使用哪种方法进行的压缩</p><p>目前许多网站通常会压缩 HTML 文档，脚本和样式表的压缩也是值得的（包括 XML 和 JSON 在内的任何文本响应理论上都值得被压缩）。但是，图片和 PDF 文件不应该被压缩，因为它们本来已经被压缩了。</p><h2 id="使用多个域名"><a href="#使用多个域名" class="headerlink" title="使用多个域名"></a>使用多个域名</h2><p>Chrome 等现代化浏览器，都会有同域名限制并发下载数的情况，不同的浏览器及版本都不一样，使用不同的域名可以最大化下载线程，但注意保持在 2~4 个域名内，以避免 DNS 查询损耗。</p><h2 id="避免图片src为空"><a href="#避免图片src为空" class="headerlink" title="避免图片src为空"></a>避免图片src为空</h2><p>虽然 src 属性为空字符串，但浏览器仍然会向服务器发起一个 HTTP 请求：</p><p>IE 向页面所在的目录发送请求； Safari、Chrome、Firefox 向页面本身发送请求； Opera 不执行任何操作。</p><h1 id="页面渲染优化"><a href="#页面渲染优化" class="headerlink" title="页面渲染优化"></a>页面渲染优化</h1><p>Webkit 渲染引擎流程：</p><ul><li>处理 HTML 并构建 DOM 树</li><li>处理 CSS 构建 CSS 规则树(CSSOM)</li><li>DOM Tree 和 CSSOM Tree 合成一棵渲染树 Render Tree</li><li>根据渲染树来布局，计算每个节点的位置</li><li>调用 GPU 绘制，合成图层，显示在屏幕上</li></ul><h2 id="避免css阻塞"><a href="#避免css阻塞" class="headerlink" title="避免css阻塞"></a>避免css阻塞</h2><p>css影响renderTree的构建，会阻塞页面的渲染，因此应该<strong>尽早（将 CSS 放在 head 标签里）和尽快（启用 CDN 实现静态资源加载速度的优化)的</strong>将css资源加载</p><h2 id="降低css选择器的复杂度"><a href="#降低css选择器的复杂度" class="headerlink" title="降低css选择器的复杂度"></a>降低css选择器的复杂度</h2><p>浏览器读取选择器，遵循的原则是从选择器的右边到左边读取。</p><ul><li>减少嵌套：最多不要超过三层，并且后代选择器的开销较高，慎重使用</li><li>避免使用通配符，对用到的元素进行匹配即可</li><li>利用继承，避免重复匹配和定义</li><li>正确使用类选择器和id选择器</li></ul><h2 id="避免使用CSS-表达式"><a href="#避免使用CSS-表达式" class="headerlink" title="避免使用CSS 表达式"></a>避免使用CSS 表达式</h2><p>css 表达式会被频繁地计算。</p><h2 id="避免js阻塞"><a href="#避免js阻塞" class="headerlink" title="避免js阻塞"></a>避免js阻塞</h2><p>js可以修改CSSOM和DOM，因此js会阻塞页面的解析和渲染，并且会等待css资源的加载。也就是说js会抢走渲染引擎的控制权。所以我们需要给js资源添加defer或者async，延迟js脚本的执行。</p><h2 id="使用外链式的js和css"><a href="#使用外链式的js和css" class="headerlink" title="使用外链式的js和css"></a>使用外链式的js和css</h2><p>在现实环境中使用外部文件通常会产生较快的页面，因为 JavaScript 和 CSS 有机会被浏览器缓存起来。对于内联的情况，由于 HTML 文档通常不会被配置为可以进行缓存的，所以每次请求 HTML 文档都要下载 JavaScript 和 CSS。所以，如果 JavaScript 和 CSS 在外部文件中，浏览器可以缓存它们，HTML 文档的大小会被减少而不必增加 HTTP 请求数量。</p><h2 id="使用字体图标-iconfont-代替图片图标"><a href="#使用字体图标-iconfont-代替图片图标" class="headerlink" title="使用字体图标 iconfont 代替图片图标"></a>使用字体图标 iconfont 代替图片图标</h2><ul><li>图片会增加网络请求次数，从而拖慢页面加载时间</li><li>iconfont可以很好的缩放并且不会添加额外的请求</li></ul><h2 id="首屏加载优化"><a href="#首屏加载优化" class="headerlink" title="首屏加载优化"></a>首屏加载优化</h2><ul><li>使用骨架屏或者动画优化用户体验</li><li>资源按需加载，首页不需要的资源延迟加载</li></ul><h2 id="减少重绘和回流"><a href="#减少重绘和回流" class="headerlink" title="减少重绘和回流"></a>减少重绘和回流</h2><ul><li>增加多个节点使用documentFragment：不是真实dom的部分，不会引起重绘和回流</li><li>用 translate 代替 top ，因为 top 会触发回流，但是translate不会。所以translate会比top节省了一个layout的时间</li><li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）；opacity 代替 visiability，visiability会触发重绘（paint），但opacity不会。</li><li>把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来</li><li>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量for (let i &#x3D; 0; i &lt; 1000; i++) { &#x2F;&#x2F; 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector(‘.test’).style.offsetTop) } 复制代码</li><li>尽量少用table布局，table布局的话，每次有单元格布局改变，都会进行整个tabel回流重绘；</li><li>最好别频繁去操作DOM节点，最好把需要操作的样式，提前写成class，之后需要修改。只需要修改一次，需要修改的时候，直接修改className，做成一次性更新多条css DOM属性，一次回流重绘总比多次回流重绘要付出的成本低得多；</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame</li><li>每次访问DOM的偏移量属性的时候，例如获取一个元素的scrollTop、scrollLeft、scrollWidth、offsetTop、offsetLeft、offsetWidth、offsetHeight之类的属性，浏览器为了保证值的正确也会回流取得最新的值，所以如果你要多次操作，最取完做个缓存。更加不要for循环中访问DOM偏移量属性，而且使用的时候，最好定义一个变量，把要需要的值赋值进去，进行值缓存，把回流重绘的次数减少；</li><li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层。</li></ul><h1 id="JS中的性能优化"><a href="#JS中的性能优化" class="headerlink" title="JS中的性能优化"></a>JS中的性能优化</h1><h2 id="使用事件委托"><a href="#使用事件委托" class="headerlink" title="使用事件委托"></a>使用事件委托</h2><h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><h2 id="尽量不要使用JS动画"><a href="#尽量不要使用JS动画" class="headerlink" title="尽量不要使用JS动画"></a>尽量不要使用<a href="https://link.juejin.cn/?target=https://zh.javascript.info/js-animation" title="https:&#x2F;&#x2F;link.juejin.cn?target&#x3D;https%3A%2F%2Fzh.javascript.info%2Fjs-animation">JS动画</a></h2><p><a href="https://link.juejin.cn/?target=https://www.runoob.com/css3/css3-animations.html" title="https:&#x2F;&#x2F;link.juejin.cn?target&#x3D;https%3A%2F%2Fwww.runoob.com%2Fcss3%2Fcss3-animations.html">css3动画</a>和<a href="https://juejin.cn/post/7008811592733655077" title="https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7008811592733655077">canvas动画</a>都比JS动画性能好</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>复杂的计算开启webWorker进行计算，避免页面假死</p><h2 id="计算结果缓存"><a href="#计算结果缓存" class="headerlink" title="计算结果缓存"></a>计算结果缓存</h2><p>减少运算次数，比如vue中的computed</p><h1 id="图片的优化"><a href="#图片的优化" class="headerlink" title="图片的优化"></a>图片的优化</h1><h2 id="雪碧图"><a href="#雪碧图" class="headerlink" title="雪碧图"></a>雪碧图</h2><p>借助减少http请求次数来进行优化</p><h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><p>在图片即将进入可视区域的时候进行加载</p><h2 id="使用CSS3代替图片"><a href="#使用CSS3代替图片" class="headerlink" title="使用CSS3代替图片"></a>使用CSS3代替图片</h2><p>有很多图片使用 CSS 效果（渐变、阴影等）就能画出来，这种情况选择 CSS3 效果更好</p><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><p>压缩方法有两种，一是通过在线网站进行压缩，二是通过 webpack 插件 image-webpack-loader。它是基于 <a href="https://link.juejin.cn/?target=https://link.segmentfault.com/?enc=6SFBEjb9%252FrzIZGfOUStOJw%253D%253D.%252Bf0Zw4j1CQG%252B3h9FDEUcmMrWACqiCYz06EmP4BxMagRAdgpHKY5LqwmVWYq9L%252FENvVhS9SUbVatpPn6kZMHKp%252B%252FxXnsenceQ5QcMKwcb8ks%253D" title="https:&#x2F;&#x2F;link.juejin.cn?target&#x3D;https%3A%2F%2Flink.segmentfault.com%2F%3Fenc%3D6SFBEjb9%252FrzIZGfOUStOJw%253D%253D.%252Bf0Zw4j1CQG%252B3h9FDEUcmMrWACqiCYz06EmP4BxMagRAdgpHKY5LqwmVWYq9L%252FENvVhS9SUbVatpPn6kZMHKp%252B%252FxXnsenceQ5QcMKwcb8ks%253D">imagemin</a> 这个 Node 库来实现图片压缩的。</p><h2 id="使用渐进式jpeg"><a href="#使用渐进式jpeg" class="headerlink" title="使用渐进式jpeg"></a>使用渐进式jpeg</h2><p>使用渐进式jpeg，会提高用户体验 <a href="https://link.juejin.cn/?target=https://www.biaodianfu.com/progressive-jpeg.html" title="https:&#x2F;&#x2F;link.juejin.cn?target&#x3D;https%3A%2F%2Fwww.biaodianfu.com%2Fprogressive-jpeg.html">参考文章</a></p><h2 id="使用-webp-格式的图片"><a href="#使用-webp-格式的图片" class="headerlink" title="使用 webp 格式的图片"></a>使用 webp 格式的图片</h2><p>webp 是一种新的图片文件格式，它提供了有损压缩和无损压缩两种方式。在相同图片质量下，webp 的体积比 png 和 jpg 更小。</p><h1 id="webpack打包优化"><a href="#webpack打包优化" class="headerlink" title="webpack打包优化"></a>webpack打包优化</h1><h2 id="缩小loader-匹配范围"><a href="#缩小loader-匹配范围" class="headerlink" title="缩小loader 匹配范围"></a>缩小loader 匹配范围</h2><ul><li>优化loader配置</li><li>test、include、exclude三个配置项来缩⼩loader的处理范围</li><li>推荐include</li></ul><h2 id="resolve-modules"><a href="#resolve-modules" class="headerlink" title="resolve.modules"></a>resolve.modules</h2><p>resolve.modules用于配置webpack去哪些目录下寻找第三方模块，默认是 node_modules。</p><p>寻找第三方，默认是在当前项目目录下的node_modules里面去找，如果没有找到，就会去上一级目录..&#x2F;node_modules找，再没有会去..&#x2F;..&#x2F;node_modules中找，以此类推，和Node.js的模块寻找机制很类似。</p><p>如果我们的第三⽅模块都安装在了项⽬根⽬录下，就可以直接指明这个路径。</p><h2 id="resolve-extensions"><a href="#resolve-extensions" class="headerlink" title="resolve.extensions"></a>resolve.extensions</h2><p>resolve.extensions在导⼊语句没带⽂件后缀时，webpack会⾃动带上后缀后，去尝试查找⽂件是否存在。</p><ul><li>后缀尝试列表尽量的⼩</li><li>导⼊语句尽量的带上后缀。</li></ul><p>如果想优化到极致的话，不建议用extensionx, 因为它会消耗一些性能。虽然它可以带来一些便利。</p><h2 id="抽离css"><a href="#抽离css" class="headerlink" title="抽离css"></a>抽离css</h2><p>借助mini-css-extract-plugin:本插件会将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载。。</p><h2 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h2><h3 id="JS代码压缩"><a href="#JS代码压缩" class="headerlink" title="JS代码压缩"></a>JS代码压缩</h3><p>mode:production，使用的是terser-webpack-plugin</p><h3 id="CSS代码压缩"><a href="#CSS代码压缩" class="headerlink" title="CSS代码压缩"></a>CSS代码压缩</h3><p>css-minimizer-webpack-plugin</p><h3 id="Html文件代码压缩"><a href="#Html文件代码压缩" class="headerlink" title="Html文件代码压缩"></a>Html文件代码压缩</h3><p>设置了minify，实际会使用另一个插件html-minifier-terser</p><h3 id="文件大小压缩"><a href="#文件大小压缩" class="headerlink" title="文件大小压缩"></a>文件大小压缩</h3><p>对文件的大小进行压缩，减少http传输过程中宽带的损耗</p><h3 id="图片压缩-1"><a href="#图片压缩-1" class="headerlink" title="图片压缩"></a>图片压缩</h3><p>一般来说在打包之后，一些图片文件的大小是远远要比 js 或者 css 文件要来的大，所以图片压缩较为重要</p><p>配置方法如下：</p><h2 id="Tree-shaking-去除死代码"><a href="#Tree-shaking-去除死代码" class="headerlink" title="Tree shaking 去除死代码"></a>Tree shaking 去除死代码</h2><p>Tree Shaking 是一个术语，在计算机中表示消除死代码，依赖于ES Module的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）</p><p>在webpack实现Tree shaking有两种不同的方案：</p><ul><li>usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的</li><li>sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用</li></ul><p>两种不同的配置方案， 有不同的效果</p><h4 id="usedExports"><a href="#usedExports" class="headerlink" title="usedExports"></a>usedExports</h4><p>配置方法也很简单，只需要将usedExports设为true</p><p>使用之后，没被用上的代码在webpack打包中会加入unused harmony export mul注释，用来告知 Terser 在优化时，可以删除掉这段代码</p><h4 id="sideEffects"><a href="#sideEffects" class="headerlink" title="sideEffects"></a>sideEffects</h4><p>sideEffects用于告知webpack compiler哪些模块时有副作用，配置方法是在package.json中设置sideEffects属性</p><p>如果sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports</p><p>如果有些文件需要保留，可以设置为数组的形式</p><p>上述都是关于javascript的tree shaking，css同样也能够实现tree shaking</p><h4 id="css-tree-shaking"><a href="#css-tree-shaking" class="headerlink" title="css tree shaking"></a>css tree shaking</h4><p>css进行tree shaking优化可以安装PurgeCss插件</p><ul><li>paths：表示要检测哪些目录下的内容需要被分析，配合使用glob</li><li>默认情况下，Purgecss会将我们的html标签的样式移除掉，如果我们希望保留，可以添加一个safelist的属性</li></ul><h2 id="babel-plugin-transform-runtime减少ES6转化ES5的冗余"><a href="#babel-plugin-transform-runtime减少ES6转化ES5的冗余" class="headerlink" title="babel-plugin-transform-runtime减少ES6转化ES5的冗余"></a>babel-plugin-transform-runtime减少ES6转化ES5的冗余</h2><p>Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数。在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require(‘babel-runtime&#x2F;helpers&#x2F;createClass’) 的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。</p><h2 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h2><p>将代码分离到不同的bundle中，之后我们可以按需加载，或者并行加载这些文件</p><p>默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度</p><p>代码分离可以分出更小的bundle，以及控制资源加载优先级，提供代码的加载性能</p><p>这里通过splitChunksPlugin来实现，该插件webpack已经默认安装和集成，只需要配置即可</p><p>默认配置中，chunks仅仅针对于异步（async）请求，我们可以设置为initial或者all</p><p>splitChunks主要属性有如下：</p><ul><li>Chunks，对同步代码还是异步代码进行处理</li><li>minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分</li><li>maxSize： 将大于maxSize的包，拆分为不小于minSize的包</li><li>minChunks：被引入的次数，默认是1</li></ul><h2 id="多线程打包提升打包速度"><a href="#多线程打包提升打包速度" class="headerlink" title="多线程打包提升打包速度"></a>多线程打包提升打包速度</h2><h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><ol><li>v-for添加key</li><li>路由懒加载</li><li>第三方插件按需引入</li><li>合理使用computed和watch</li><li>v-for的同时避免使用v-if</li><li>destory时销毁事件：比如addEventListener添加的事件、setTimeout、setInterval、bus.$on绑定的监听事件等</li></ol><h1 id="react"><a href="#react" class="headerlink" title="react"></a>react</h1><ol><li>map循环展示添加key</li><li>路由懒加载</li><li>第三方插件按需引入</li><li>使用shouldComponentUpdate，memo或者pureComponent避免不必要的渲染</li><li>合理使用useMemo、memo、useCallback他们三个的应用场景都是缓存结果，当依赖值没有改变时避免不必要的计算或者渲染。</li></ol><ul><li><ul><li>useCallback 是针对<strong>函数</strong>进行“记忆”的，当它依赖项没有发生改变时，那么该函数的引用并不会随着组件的刷新而被重新赋值。当我们觉得一个函数不需要随着组件的更新而更新引用地址的时候，我们就可以使用 useCallback 去修饰它。</li><li>React.memo 是对<strong>组件</strong>进行 “记忆”，当它接收的 props 没有发生改变的时候，那么它将返回上次渲染的结果，不会重新执行函数返回新的渲染结果。</li><li>React.useMemo是针对 <strong>值计算</strong> 的一种“记忆“，当依赖项没有发生改变时，那么无需再去计算，直接使用之前的值，对于组件而言，这带来的一个好处就是，可以减少一些计算，避免一些多余的渲染。当我们遇到一些数据需要在组件内部进行计算的时候，可以考虑一下 React.useMemo</li></ul></li></ul><p>本文转自 <a href="https://juejin.cn/post/7272234312057978914#heading-27">https://juejin.cn/post/7272234312057978914#heading-27</a>，如有侵权，请联系删除。</p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>手写promise</title>
    <link href="/2024/09/24/Interview/js/%E6%89%8B%E5%86%99promise/"/>
    <url>/2024/09/24/Interview/js/%E6%89%8B%E5%86%99promise/</url>
    
    <content type="html"><![CDATA[<p>手写一个简单的 Promise 实现可以帮助理解 Promise 的基本原理。以下是一个基本的 Promise 实现，包括 <code>resolve</code>、<code>reject</code> 和 <code>then</code> 方法。</p><h3 id="1-Promise-实现"><a href="#1-Promise-实现" class="headerlink" title="1. Promise 实现"></a>1. <strong>Promise 实现</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&#x27;pending&#x27;</span>; <span class="hljs-comment">// 初始状态</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;  <span class="hljs-comment">// 成功的值</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;  <span class="hljs-comment">// 失败的原因</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span> = []; <span class="hljs-comment">// 存放成功的回调</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span> = []; <span class="hljs-comment">// 存放失败的回调</span><br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>(value));<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>(reason));<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 执行传入的 executor 函数</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">executor</span>(resolve, reject);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-title function_">reject</span>(error);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// then 方法</span><br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleFulfilled</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>          <span class="hljs-title function_">resolve</span>(result);<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>          <span class="hljs-title function_">reject</span>(error);<br>        &#125;<br>      &#125;;<br><br>      <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRejected</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>          <span class="hljs-title function_">resolve</span>(result);<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>          <span class="hljs-title function_">reject</span>(error);<br>        &#125;<br>      &#125;;<br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&#x27;fulfilled&#x27;</span>) &#123;<br>        <span class="hljs-title function_">handleFulfilled</span>();<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&#x27;rejected&#x27;</span>) &#123;<br>        <span class="hljs-title function_">handleRejected</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">push</span>(handleFulfilled);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(handleRejected);<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2. 使用示例"></a>2. <strong>使用示例</strong></h3><p>以下是如何使用自定义的 <code>MyPromise</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;成功！&#x27;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br>promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出: 成功！</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;继续处理&#x27;</span>;<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出: 继续处理</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="3-特点"><a href="#3-特点" class="headerlink" title="3. 特点"></a>3. <strong>特点</strong></h3><ul><li><strong>状态管理</strong>：Promise 的状态只能从 <code>pending</code> 变为 <code>fulfilled</code> 或 <code>rejected</code>，并且一旦变更，不能再变更。</li><li><strong>回调管理</strong>：成功和失败的回调被存储在数组中，只有在状态变更时调用。</li><li><strong>链式调用</strong>：<code>then</code> 方法返回新的 Promise，支持链式调用。</li></ul><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. <strong>总结</strong></h3><p>这个简单的 Promise 实现展示了 Promise 的核心机制。在实际项目中，可以考虑更全面的实现，比如支持链式调用的返回值、异常处理等。</p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>防抖和节流</title>
    <link href="/2024/09/24/Interview/js/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <url>/2024/09/24/Interview/js/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>防抖（Debounce）和节流（Throttle）是两种常用的性能优化技术，主要用于控制函数执行的频率，尤其是在处理高频事件时（如滚动、输入等）。</p><h3 id="防抖（Debounce）"><a href="#防抖（Debounce）" class="headerlink" title="防抖（Debounce）"></a>防抖（Debounce）</h3><p><strong>定义</strong>：<br>防抖是一种确保某个函数在一定时间内只被执行一次的策略。它通常用于处理用户输入事件，避免在输入过程中频繁触发函数。</p><p><strong>实现原理</strong>：</p><ul><li>当事件被触发时，设置一个定时器。</li><li>如果在定时器到期前再次触发事件，则清除之前的定时器，并重新设置一个新的定时器。</li><li>只有在事件不再被触发一段时间后，函数才会执行。</li></ul><p><strong>应用场景</strong>：</p><ol><li><strong>输入框搜索</strong>：在用户输入时，防止每次输入都发起请求，可以在用户停止输入一段时间后再发送请求。</li><li><strong>窗口调整</strong>：在调整浏览器窗口大小时，避免频繁计算布局或样式。</li><li><strong>表单验证</strong>：在用户停止输入后进行表单验证。</li></ol><p><strong>示例代码</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait</span>) &#123;<br>  <span class="hljs-keyword">let</span> timeout;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args), wait);<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> handleInput = <span class="hljs-title function_">debounce</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;输入完成，执行请求&#x27;</span>);<br>&#125;, <span class="hljs-number">300</span>);<br></code></pre></td></tr></table></figure><h3 id="节流（Throttle）"><a href="#节流（Throttle）" class="headerlink" title="节流（Throttle）"></a>节流（Throttle）</h3><p><strong>定义</strong>：<br>节流是一种控制函数在一定时间内只能执行一次的策略。它通常用于限制函数的执行频率。</p><p><strong>实现原理</strong>：</p><ul><li>设置一个标记来跟踪函数是否正在执行。</li><li>当事件被触发时，如果标记为 false，允许执行函数，并将标记设为 true。</li><li>在函数执行完成后，定时器会在指定的时间后将标记重置为 false，允许下一次执行。</li></ul><p><strong>应用场景</strong>：</p><ol><li><strong>滚动监听</strong>：在页面滚动时，限制计算或加载操作的频率，比如无限滚动。</li><li><strong>窗口调整</strong>：在窗口大小变化时，每隔一段时间计算布局，而不是每次都计算。</li><li><strong>按钮点击</strong>：防止用户快速多次点击按钮。</li></ol><p><strong>示例代码</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, limit</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastFunc;<br>  <span class="hljs-keyword">let</span> lastRan;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!lastRan) &#123;<br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      lastRan = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(lastFunc);<br>      lastFunc = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> ((<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - lastRan) &gt;= limit) &#123;<br>          func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>          lastRan = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>        &#125;<br>      &#125;, limit - (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - lastRan));<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> handleScroll = <span class="hljs-title function_">throttle</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;滚动中，执行操作&#x27;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><strong>防抖</strong>：用于延迟执行，常用于处理快速触发的事件（如输入），只在事件停止后执行一次。</li><li><strong>节流</strong>：用于限制频繁执行，常用于需要定期执行的事件（如滚动、窗口调整），确保函数在一定时间内最多执行一次。</li></ul><p>选择适当的策略可以有效提升性能和用户体验。</p><blockquote><p><em>小tips</em>一般开发中<br>防抖用于button点击，窗口调整<br>节流用于滚动下拉，下拉框联想</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>箭头函数和普通函数对比</title>
    <link href="/2024/09/24/Interview/js/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%AF%B9%E6%AF%94/"/>
    <url>/2024/09/24/Interview/js/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<p>箭头函数相对于普通函数（函数声明和函数表达式）的性能在大多数情况下是相似的，主要的区别在于它们的语法和行为特性，而不是性能。以下是一些关键点：</p><h3 id="1-语法简洁"><a href="#1-语法简洁" class="headerlink" title="1. 语法简洁"></a>1. <strong>语法简洁</strong></h3><ul><li>箭头函数语法更简洁，特别是在函数体只有一条语句时，不需要使用大括号和 <code>return</code>。</li><li>示例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 普通函数</span><br><span class="hljs-keyword">const</span> sum = <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><br><span class="hljs-comment">// 箭头函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-this-绑定"><a href="#2-this-绑定" class="headerlink" title="2. this 绑定"></a>2. <strong><code>this</code> 绑定</strong></h3><ul><li>箭头函数没有自己的 <code>this</code>，它会继承外部作用域的 <code>this</code>。这对于处理回调函数时，尤其是在类的方法中，避免了手动绑定 <code>this</code> 的问题。</li><li>示例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++; <span class="hljs-comment">// 这里的 this 指向 Counter 实例</span><br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-性能"><a href="#3-性能" class="headerlink" title="3. 性能"></a>3. <strong>性能</strong></h3><ul><li>在大多数场景中，箭头函数和普通函数的性能差异微乎其微，通常不需要担心。</li><li>性能瓶颈更多地来源于代码逻辑和算法复杂度，而不是函数的定义方式。</li></ul><h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. <strong>使用场景</strong></h3><ul><li>箭头函数更适合用于简短的回调函数、数组操作（如 <code>map</code>、<code>filter</code> 等），而普通函数则在需要灵活的 <code>this</code> 绑定时更为合适。</li></ul><h3 id="5-内存和创建"><a href="#5-内存和创建" class="headerlink" title="5. 内存和创建"></a>5. <strong>内存和创建</strong></h3><ul><li>在某些情况下，箭头函数可能导致内存使用略有增加，因为每次创建函数时都会创建一个新的作用域。然而，这种影响在实际应用中通常是微不足道的。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>箭头函数与普通函数在性能上没有显著差异，主要的区别在于语法和 <code>this</code> 绑定的行为。选择使用哪种函数类型，应根据具体场景和可读性来决定。</p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端安全相关</title>
    <link href="/2024/09/24/Interview/js/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/09/24/Interview/js/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>前端安全是保护用户数据和应用程序免受攻击和滥用的重要措施。以下是一些常见的前端安全问题及其防护措施：</p><h3 id="1-跨站脚本攻击（XSS）"><a href="#1-跨站脚本攻击（XSS）" class="headerlink" title="1. 跨站脚本攻击（XSS）"></a>1. <strong>跨站脚本攻击（XSS）</strong></h3><ul><li><strong>定义</strong>：攻击者通过注入恶意脚本到网页中，使得浏览器执行这些脚本，从而窃取用户信息或执行其他恶意操作。</li><li><strong>防护措施</strong>：<ul><li><strong>输入验证</strong>：对用户输入进行严格验证和清理，避免注入攻击。</li><li><strong>输出编码</strong>：在输出到 HTML、JavaScript、CSS 等之前，使用合适的编码方法对数据进行转义。</li><li><strong>内容安全策略（CSP）</strong>：配置 CSP 头，限制可以执行的脚本来源。</li></ul></li></ul><h3 id="2-跨站请求伪造（CSRF）"><a href="#2-跨站请求伪造（CSRF）" class="headerlink" title="2. 跨站请求伪造（CSRF）"></a>2. <strong>跨站请求伪造（CSRF）</strong></h3><ul><li><strong>定义</strong>：攻击者诱导用户在已登录的情况下执行不必要的请求，可能导致数据篡改或其他操作。</li><li><strong>防护措施</strong>：<ul><li><strong>CSRF Token</strong>：为每个用户会话生成随机 token，并在请求中验证。</li><li><strong>SameSite Cookie 属性</strong>：设置 cookie 的 SameSite 属性，限制第三方网站访问。</li></ul></li></ul><h3 id="3-点击劫持（Clickjacking）"><a href="#3-点击劫持（Clickjacking）" class="headerlink" title="3. 点击劫持（Clickjacking）"></a>3. <strong>点击劫持（Clickjacking）</strong></h3><ul><li><strong>定义</strong>：攻击者通过嵌套网页诱导用户点击隐藏的链接或按钮。</li><li><strong>防护措施</strong>：<ul><li><strong>X-Frame-Options 头</strong>：设置此头为 <code>DENY</code> 或 <code>SAMEORIGIN</code>，防止网页被嵌入到其他页面中。</li><li><strong>Content Security Policy</strong>：使用 CSP 的 <code>frame-ancestors</code> 指令，控制允许嵌入页面的来源。</li></ul></li></ul><h3 id="4-信息泄露"><a href="#4-信息泄露" class="headerlink" title="4. 信息泄露"></a>4. <strong>信息泄露</strong></h3><ul><li><strong>定义</strong>：敏感信息（如 API 密钥、用户数据）被意外公开或通过浏览器控制台等途径泄露。</li><li><strong>防护措施</strong>：<ul><li><strong>环境变量</strong>：将敏感信息存储在环境变量中，避免在前端代码中硬编码。</li><li><strong>最小权限原则</strong>：限制前端访问敏感数据的权限，使用最小化的 API。</li></ul></li></ul><h3 id="5-安全配置和依赖管理"><a href="#5-安全配置和依赖管理" class="headerlink" title="5. 安全配置和依赖管理"></a>5. <strong>安全配置和依赖管理</strong></h3><ul><li><strong>定义</strong>：第三方库和框架可能存在安全漏洞。</li><li><strong>防护措施</strong>：<ul><li><strong>依赖审计</strong>：定期审查和更新依赖项，使用工具（如 npm audit）检查已知漏洞。</li><li><strong>使用安全的库</strong>：选择知名和维护活跃的库，避免使用不受信任的库。</li></ul></li></ul><h3 id="6-加密和安全通信"><a href="#6-加密和安全通信" class="headerlink" title="6. 加密和安全通信"></a>6. <strong>加密和安全通信</strong></h3><ul><li><strong>定义</strong>：数据在传输过程中可能被窃取或篡改。</li><li><strong>防护措施</strong>：<ul><li><strong>HTTPS</strong>：使用 HTTPS 加密数据传输，防止中间人攻击。</li><li><strong>HSTS</strong>：使用 HTTP 严格传输安全（HSTS）头，强制使用 HTTPS。</li></ul></li></ul><h3 id="7-恶意软件和网络钓鱼"><a href="#7-恶意软件和网络钓鱼" class="headerlink" title="7. 恶意软件和网络钓鱼"></a>7. <strong>恶意软件和网络钓鱼</strong></h3><ul><li><strong>定义</strong>：通过欺骗用户获取敏感信息或植入恶意软件。</li><li><strong>防护措施</strong>：<ul><li><strong>用户教育</strong>：提高用户对网络钓鱼的警觉性，提供安全提示。</li><li><strong>防火墙和安全软件</strong>：使用浏览器扩展和安全软件监测和阻止恶意行为。</li></ul></li></ul><h3 id="8-日志和监控"><a href="#8-日志和监控" class="headerlink" title="8. 日志和监控"></a>8. <strong>日志和监控</strong></h3><ul><li><strong>定义</strong>：监控应用程序活动以发现安全威胁。</li><li><strong>防护措施</strong>：<ul><li><strong>记录安全事件</strong>：记录用户登录、错误、异常等事件，及时分析和响应。</li><li><strong>使用监控工具</strong>：利用工具（如 Sentry、LogRocket）监控和分析前端错误和异常。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前端安全是一个复杂而重要的领域，涉及多个方面的防护。通过采取有效的安全措施和最佳实践，可以显著降低潜在的安全风险，保护用户数据和应用程序安全。</p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>safety</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓存机制</title>
    <link href="/2024/09/24/Interview/js/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/09/24/Interview/js/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>在浏览器缓存中，<strong>强制缓存</strong>和<strong>协商缓存</strong>是两种重要的缓存机制，它们的作用和使用场景有所不同。</p><h3 id="强制缓存（Cache-Control）"><a href="#强制缓存（Cache-Control）" class="headerlink" title="强制缓存（Cache-Control）"></a>强制缓存（Cache-Control）</h3><ul><li><strong>定义</strong>：当资源在强制缓存中时，浏览器会直接使用缓存的资源，而不发起网络请求。</li><li><strong>控制方式</strong>：<ul><li><strong>HTTP 响应头</strong>：使用 <code>Cache-Control</code>、<code>Expires</code> 来设置。</li><li><code>Cache-Control</code> 的常见指令：<ul><li><code>max-age=&lt;seconds&gt;</code>：指定资源在缓存中有效的时间。</li><li><code>public</code>：任何缓存都可以缓存该响应。</li><li><code>private</code>：只有用户的浏览器可以缓存。</li></ul></li></ul></li><li><strong>示例</strong>：</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=3600<br></code></pre></td></tr></table></figure><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><ul><li><strong>定义</strong>：当强制缓存过期或未命中时，浏览器会发起请求，并通过一些条件来判断缓存的有效性。</li><li><strong>控制方式</strong>：<ul><li><strong>HTTP 请求头</strong>：使用 <code>If-None-Match</code>（与 <code>ETag</code> 一起使用）或 <code>If-Modified-Since</code>（与 <code>Last-Modified</code> 一起使用）。</li></ul></li><li><strong>流程</strong>：<ul><li>浏览器发送请求时附带条件头。</li><li>服务器根据条件判断资源是否被修改：<ul><li>如果未修改，返回 <code>304 Not Modified</code> 响应，浏览器使用缓存。</li><li>如果修改，返回新的资源。</li></ul></li></ul></li><li><strong>示例</strong>：</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">If-Modified-Since</span><span class="hljs-punctuation">: </span>Sat, 29 Oct 2022 19:43:31 GMT<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>强制缓存</strong>：通过设置时间等直接决定是否使用缓存，效率高。</li><li><strong>协商缓存</strong>：在强制缓存过期后，通过服务器确认资源是否被修改，保证数据的时效性。</li></ul><p>使用这两种缓存机制可以有效提高页面加载速度和用户体验。</p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件循环机制</title>
    <link href="/2024/09/24/Interview/js/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/09/24/Interview/js/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p><strong>事件循环机制</strong>（Event Loop）是 JavaScript 中处理异步操作的核心机制。由于 JavaScript 是单线程语言，它需要通过事件循环机制来协调同步任务和异步任务的执行，使得程序能够以<strong>非阻塞</strong>的方式处理 I&#x2F;O 操作、定时器、用户交互等异步事件。</p><h3 id="1-JavaScript-执行模型"><a href="#1-JavaScript-执行模型" class="headerlink" title="1. JavaScript 执行模型"></a>1. <strong>JavaScript 执行模型</strong></h3><p>JavaScript 的执行分为两种任务：</p><ul><li><strong>同步任务</strong>：直接在主线程上排队执行，只有当前任务完成后，才能执行下一个任务。</li><li><strong>异步任务</strong>：不会立即执行，异步操作将注册回调，当异步任务完成后，回调函数会被放入任务队列中，等待主线程空闲时再执行。</li></ul><h3 id="2-事件循环的核心概念"><a href="#2-事件循环的核心概念" class="headerlink" title="2. 事件循环的核心概念"></a>2. <strong>事件循环的核心概念</strong></h3><p>事件循环的工作流程可以概括为以下步骤：</p><ol><li><strong>执行所有同步任务</strong>：首先执行全局代码中的同步任务。</li><li><strong>检查异步任务队列</strong>：主线程空闲后，检查是否有异步任务完成并将其回调函数放入任务队列。</li><li><strong>执行任务队列中的回调</strong>：按照顺序从任务队列中取出回调函数，并将其执行。</li><li><strong>重复步骤 2 和 3</strong>：不断重复此过程，以确保事件能够持续处理。</li></ol><h3 id="3-任务队列类型"><a href="#3-任务队列类型" class="headerlink" title="3. 任务队列类型"></a>3. <strong>任务队列类型</strong></h3><p>任务队列（任务队列或消息队列）分为两类：</p><ul><li><strong>宏任务队列（Macro Task Queue）</strong>：包括整体代码（script）、<code>setTimeout</code>、<code>setInterval</code>、<code>I/O</code> 操作、事件监听等。</li><li><strong>微任务队列（Micro Task Queue）</strong>：包括 <code>Promise.then()</code>、<code>process.nextTick()</code>、<code>MutationObserver</code> 等。</li></ul><p>事件循环在每一轮中都会优先执行所有的微任务队列，然后再执行一个宏任务。</p><h3 id="4-事件循环的执行顺序"><a href="#4-事件循环的执行顺序" class="headerlink" title="4. 事件循环的执行顺序"></a>4. <strong>事件循环的执行顺序</strong></h3><p>事件循环的执行顺序非常关键，遵循以下流程：</p><ol><li><strong>同步代码先执行</strong>：主线程上所有同步任务先按顺序执行。</li><li><strong>执行所有的微任务</strong>：当同步代码执行完后，立即执行微任务队列中的所有微任务，直到微任务队列清空。</li><li><strong>执行一个宏任务</strong>：接着执行宏任务队列中的第一个宏任务。</li><li><strong>循环往复</strong>：每次宏任务执行完后，都会进入微任务队列，优先执行微任务，再回到宏任务，形成循环。</li></ol><h3 id="5-宏任务与微任务的示例"><a href="#5-宏任务与微任务的示例" class="headerlink" title="5. 宏任务与微任务的示例"></a>5. <strong>宏任务与微任务的示例</strong></h3><p>下面通过示例展示宏任务和微任务的执行顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>); <span class="hljs-comment">// 同步任务</span><br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>); <span class="hljs-comment">// 宏任务</span><br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>); <span class="hljs-comment">// 微任务</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;4&#x27;</span>); <span class="hljs-comment">// 同步任务</span><br></code></pre></td></tr></table></figure><h4 id="执行顺序解析："><a href="#执行顺序解析：" class="headerlink" title="执行顺序解析："></a>执行顺序解析：</h4><ol><li>首先执行同步任务，依次打印 <code>&#39;1&#39;</code> 和 <code>&#39;4&#39;</code>。</li><li>将 <code>setTimeout</code> 回调放入宏任务队列，并将 <code>Promise.then</code> 回调放入微任务队列。</li><li>执行完同步代码后，进入微任务阶段，执行微任务 <code>Promise.then</code> 回调，打印 <code>&#39;3&#39;</code>。</li><li>最后进入宏任务阶段，执行 <code>setTimeout</code> 回调，打印 <code>&#39;2&#39;</code>。</li></ol><p>最终输出顺序为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>4<br>3<br>2<br></code></pre></td></tr></table></figure><h3 id="6-示例详解：宏任务与微任务交替"><a href="#6-示例详解：宏任务与微任务交替" class="headerlink" title="6. 示例详解：宏任务与微任务交替"></a>6. <strong>示例详解：宏任务与微任务交替</strong></h3><p>为了更好地理解事件循环，可以再来看一个更复杂的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;B&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;C&#x27;</span>);<br>&#125;);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;D&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;E&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;F&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="执行顺序解析：-1"><a href="#执行顺序解析：-1" class="headerlink" title="执行顺序解析："></a>执行顺序解析：</h4><ol><li>同步任务依次执行，打印 <code>&#39;A&#39;</code> 和 <code>&#39;F&#39;</code>。</li><li>宏任务 <code>setTimeout</code> 的回调进入宏任务队列，而 <code>Promise.then</code> 的回调进入微任务队列。</li><li>同步任务执行完毕后，进入微任务阶段，执行所有微任务，依次打印 <code>&#39;C&#39;</code> 和 <code>&#39;E&#39;</code>。</li><li>微任务执行完毕后，进入宏任务阶段，执行宏任务队列中的回调，依次打印 <code>&#39;B&#39;</code> 和 <code>&#39;D&#39;</code>。</li></ol><p>最终输出顺序为：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span><br><span class="hljs-variable">F</span><br><span class="hljs-built_in">C</span><br><span class="hljs-built_in">E</span><br><span class="hljs-variable">B</span><br><span class="hljs-built_in">D</span><br></code></pre></td></tr></table></figure><h3 id="7-浏览器中的事件循环"><a href="#7-浏览器中的事件循环" class="headerlink" title="7. 浏览器中的事件循环"></a>7. <strong>浏览器中的事件循环</strong></h3><p>在浏览器环境中，事件循环与 UI 渲染之间也存在密切联系。每次宏任务执行结束后，浏览器有机会去<strong>渲染页面</strong>，所以页面的更新通常会在宏任务结束后执行，而不会在微任务中间插入。</p><h3 id="8-Node-js-中的事件循环"><a href="#8-Node-js-中的事件循环" class="headerlink" title="8. Node.js 中的事件循环"></a>8. <strong>Node.js 中的事件循环</strong></h3><p>在 Node.js 中，事件循环的机制与浏览器类似，但有一些区别。Node.js 的事件循环中有多个阶段，每个阶段都有不同类型的任务处理。例如：</p><ul><li><strong>timers 阶段</strong>：处理 <code>setTimeout</code> 和 <code>setInterval</code>。</li><li><strong>I&#x2F;O callbacks 阶段</strong>：处理系统操作的回调。</li><li><strong>poll 阶段</strong>：检索新的 I&#x2F;O 事件。</li><li><strong>check 阶段</strong>：执行 <code>setImmediate()</code> 回调。</li><li><strong>close 阶段</strong>：关闭回调处理。</li></ul><p>每个阶段结束后，都会执行微任务队列（<code>Promise.then()</code> 和 <code>process.nextTick()</code>）。</p><h3 id="9-常见面试题分析"><a href="#9-常见面试题分析" class="headerlink" title="9. 常见面试题分析"></a>9. <strong>常见面试题分析</strong></h3><h4 id="问题-1："><a href="#问题-1：" class="headerlink" title="问题 1："></a>问题 1：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;start&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;end&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>执行顺序</strong>：</p><ol><li>同步代码先执行，打印 <code>&#39;start&#39;</code> 和 <code>&#39;end&#39;</code>。</li><li><code>setTimeout</code> 回调进入宏任务队列。</li><li><code>Promise.then()</code> 回调进入微任务队列。</li><li>执行微任务队列，打印 <code>&#39;promise1&#39;</code> 和 <code>&#39;promise2&#39;</code>。</li><li>最后执行宏任务 <code>setTimeout</code>，打印 <code>&#39;setTimeout&#39;</code>。</li></ol><p><strong>输出</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;start&#x27;</span><br><span class="hljs-string">&#x27;end&#x27;</span><br><span class="hljs-string">&#x27;promise1&#x27;</span><br><span class="hljs-string">&#x27;promise2&#x27;</span><br><span class="hljs-string">&#x27;setTimeout&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>事件循环</strong>是 JavaScript 中处理异步任务的核心机制，它通过任务队列和微任务队列的配合实现非阻塞的异步操作。</li><li>在每个事件循环周期中，先执行同步代码，然后执行微任务队列，最后执行宏任务队列中的一个宏任务。</li><li>微任务（如 <code>Promise.then()</code>）优先于宏任务（如 <code>setTimeout()</code>）执行，这导致了在实际编写代码时，微任务通常会比宏任务先执行。</li></ul><h4 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>); <br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>); <br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res,rej</span>)=&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise&#x27;</span>) <br> <span class="hljs-title function_">rej</span>()<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>); <br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>); <br><br></code></pre></td></tr></table></figure><p>让我们逐行分析这段代码的输出顺序：</p><ol><li><strong><code>console.log(&#39;script start&#39;);</code></strong>：立即输出 <code>&#39;script start&#39;</code>。</li><li><strong><code>setTimeout(..., 0);</code></strong>：这个回调会被放入宏任务队列，等待执行。</li><li><strong><code>new Promise(...);</code></strong>：<ul><li>立即执行，输出 <code>&#39;promise&#39;</code>。</li><li>调用 <code>rej()</code>，进入 <code>.catch()</code>。</li></ul></li><li><strong><code>.catch(...)</code></strong>：处理拒绝状态，返回 <code>1</code>，但没有输出（只是返回值）。</li><li><strong>接下来的 <code>.then(...)</code></strong>：这个 <code>then</code> 会在微任务队列中被添加。</li><li><strong><code>console.log(&#39;script end&#39;);</code></strong>：立即输出 <code>&#39;script end&#39;</code>。</li></ol><p>接下来，微任务队列会先执行：<br>7. <strong>输出 <code>&#39;promise2&#39;</code></strong>：因为上一个 <code>then</code> 返回了一个值。</p><p>最后，宏任务队列中的 <code>setTimeout</code> 回调执行：<br>8. <strong>输出 <code>&#39;setTimeout&#39;</code></strong>。</p><p>所以，最终输出顺序为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;script start&#x27;</span><br><span class="hljs-string">&#x27;promise&#x27;</span><br><span class="hljs-string">&#x27;script end&#x27;</span><br><span class="hljs-string">&#x27;promise2&#x27;</span><br><span class="hljs-string">&#x27;setTimeout&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Event Loop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Esmodule和commonjs导入值修改</title>
    <link href="/2024/09/23/Interview/js/Esmodule%E5%92%8Ccommonjs%E5%AF%BC%E5%85%A5%E5%80%BC%E4%BF%AE%E6%94%B9/"/>
    <url>/2024/09/23/Interview/js/Esmodule%E5%92%8Ccommonjs%E5%AF%BC%E5%85%A5%E5%80%BC%E4%BF%AE%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>面试时被问到esmoudle和commonjs导出数据修改后会如何输出，当时由于紧张没答上来，现在记录下。</p><h2 id="Commonjs修改导出值"><a href="#Commonjs修改导出值" class="headerlink" title="Commonjs修改导出值"></a>Commonjs修改导出值</h2><h3 id="导出值是基础类型"><a href="#导出值是基础类型" class="headerlink" title="导出值是基础类型"></a>导出值是基础类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.cjs</span><br><span class="hljs-keyword">let</span> data = <span class="hljs-number">1</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">plusData</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>data++<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)  <span class="hljs-comment">// 1 第二次为1</span><br>&#125; <br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>data,<br>plusData<br>&#125;<br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">const</span> &#123; data, plusData &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.cjs&#x27;</span>);<br><br><span class="hljs-title function_">plusData</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);  <span class="hljs-comment">// 1</span><br><br>data++<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 2</span><br><br>data = <span class="hljs-number">100</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);  <span class="hljs-comment">// 100</span><br><br><span class="hljs-title function_">plusData</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);  <span class="hljs-comment">// 100</span><br><br></code></pre></td></tr></table></figure><h3 id="导出值是引用类型"><a href="#导出值是引用类型" class="headerlink" title="导出值是引用类型"></a>导出值是引用类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.cjs</span><br><span class="hljs-keyword">const</span> data = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">plusData</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>data.<span class="hljs-property">a</span>++<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">a</span>)  <span class="hljs-comment">// 2 //第二次为4</span><br>&#125; <br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>data,<br>plusData<br>&#125;<br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">let</span> &#123; data, plusData &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.cjs&#x27;</span>);<br><br><span class="hljs-title function_">plusData</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">a</span>); <span class="hljs-comment">// 2</span><br><br>data.<span class="hljs-property">a</span>++;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">a</span>); <span class="hljs-comment">// 3</span><br><br>data = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">100</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">a</span>); <span class="hljs-comment">// 100</span><br><br><span class="hljs-title function_">plusData</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">a</span>); <span class="hljs-comment">// 100</span><br></code></pre></td></tr></table></figure><h2 id="ESmodule"><a href="#ESmodule" class="headerlink" title="ESmodule"></a>ESmodule</h2><h3 id="导出值是基础类型-1"><a href="#导出值是基础类型-1" class="headerlink" title="导出值是基础类型"></a>导出值是基础类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">let</span> data = <span class="hljs-number">1</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">plusData</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>data++<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)  <span class="hljs-comment">// 2  // 第二次为3</span><br>&#125; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>data,<br>plusData<br>&#125;<br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">import</span> a <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span>;<br><span class="hljs-keyword">let</span> &#123; data, plusData &#125; = a;<br><span class="hljs-title function_">plusData</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);   <span class="hljs-comment">// 1</span><br><br>data.<span class="hljs-property">a</span>++;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);   <span class="hljs-comment">// 1</span><br><br>data = <span class="hljs-number">5</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);   <span class="hljs-comment">// 5</span><br><br><span class="hljs-title function_">plusData</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);  <span class="hljs-comment">// 5</span><br><br></code></pre></td></tr></table></figure><h3 id="导出值是引用类型-1"><a href="#导出值是引用类型-1" class="headerlink" title="导出值是引用类型"></a>导出值是引用类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">const</span> data = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">plusData</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>data.<span class="hljs-property">a</span>++<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">a</span>)  <span class="hljs-comment">// 2  // 第二次为4</span><br>&#125; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>data,<br>plusData<br>&#125;<br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">import</span> a <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span>;<br><span class="hljs-keyword">let</span> &#123; data, plusData &#125; = a;<br><br><span class="hljs-title function_">plusData</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 2</span><br><br>data.<span class="hljs-property">a</span>++;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);  <span class="hljs-comment">// 3</span><br><br>data = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">100</span>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);  <span class="hljs-comment">// 100</span><br><br><span class="hljs-title function_">plusData</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 100</span><br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="导出的是基础类型"><a href="#导出的是基础类型" class="headerlink" title="导出的是基础类型"></a>导出的是基础类型</h3><ol><li>ESM在调用方法修改模块中的值后，引用这个值的地方也随着改变；而CJS在调用方法后，并没有随着改变；就是因为CJS输出的是一个值的拷贝，而ESM输出的是值的引用；</li><li>不管是esm还是cjs如果直接修改导出值则内外会失去关联，此时外部修改不会影响内部</li></ol><h3 id="导出的值是引用类型"><a href="#导出的值是引用类型" class="headerlink" title="导出的值是引用类型"></a>导出的值是引用类型</h3><ol><li>不管是esm还是cjs导出引用类型内外部修改都会对原值有影响</li><li>不管是esm还是cjs如果直接修改导出值则内外会失去关联，此时外部修改不会影响内部</li></ol>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ESMoudle</tag>
      
      <tag>Commonjs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>底层的实现原理来分析 Taro 和 Uni-app 在编译成原生代码时的差异</title>
    <link href="/2024/09/23/Interview/miniprogress/uniapp%E5%92%8Ctaro/"/>
    <url>/2024/09/23/Interview/miniprogress/uniapp%E5%92%8Ctaro/</url>
    
    <content type="html"><![CDATA[<h2 id="底层的实现原理来分析-Taro-和-Uni-app-在编译成原生代码时的差异"><a href="#底层的实现原理来分析-Taro-和-Uni-app-在编译成原生代码时的差异" class="headerlink" title="底层的实现原理来分析 Taro 和 Uni-app 在编译成原生代码时的差异"></a>底层的实现原理来分析 Taro 和 Uni-app 在编译成原生代码时的差异</h2><h3 id="1-Taro-的编译机制"><a href="#1-Taro-的编译机制" class="headerlink" title="1. Taro 的编译机制"></a>1. <strong>Taro 的编译机制</strong></h3><ul><li><p><strong>虚拟 DOM 转换</strong>：</p><ul><li>Taro 使用虚拟 DOM 的概念来实现跨平台开发。开发者编写的 Vue 代码会首先被转换为 Taro 的虚拟 DOM 结构。</li><li>在编译过程中，Taro 的编译器会将这些虚拟 DOM 节点映射到目标平台的具体组件和 API，例如将 Vue 的 <code>template</code> 语法转换为小程序的 <code>wxml</code>，并在逻辑层生成与之对应的 JavaScript 逻辑。</li></ul></li><li><p><strong>逻辑层与视图层</strong>：</p><ul><li>编译后的代码分为逻辑层和视图层。逻辑层处理数据、事件和状态变化，通过 Taro 提供的 API（如 <code>setData</code>）将数据同步到视图层。</li><li>视图层则是将虚拟 DOM 渲染为平台特定的视图，比如微信小程序的 <code>wxml</code> 和 <code>wxss</code>。在这个过程中，Taro 会生成相应的原生代码，以便在小程序环境中运行。</li></ul></li><li><p><strong>多端适配</strong>：</p><ul><li>Taro 的编译器会针对不同平台的特性进行适配，例如微信小程序、支付宝小程序的组件名称、事件处理方式等。它会在编译时根据目标平台生成相应的原生代码，确保每个平台的表现一致。</li></ul></li></ul><h3 id="2-Uni-app-的编译机制"><a href="#2-Uni-app-的编译机制" class="headerlink" title="2. Uni-app 的编译机制"></a>2. <strong>Uni-app 的编译机制</strong></h3><ul><li><p><strong>直接转换为原生代码</strong>：</p><ul><li>Uni-app 的编译过程更直接，开发者的 Vue 代码在编译时会被转换为各个平台的原生代码（如小程序的 <code>wxml</code>、<code>wxss</code> 和 H5 的 HTML、CSS）。编译器直接将 Vue 的组件结构映射到对应平台的原生组件，无需经过虚拟 DOM 的模拟过程。</li></ul></li><li><p><strong>统一的 API 接口</strong>：</p><ul><li>Uni-app 在编译时会将 Vue 代码中的 API 调用（如路由、请求等）转换为适合各个平台的原生 API。例如，<code>uni.navigateTo</code> 会被编译为小程序或 H5 的对应导航逻辑。</li></ul></li><li><p><strong>平台适配层</strong>：</p><ul><li>Uni-app 内置了适配层，负责在不同平台间屏蔽 API 和组件的差异。编译时，Uni-app 会根据目标平台生成适配代码，确保开发者使用的 API 在不同平台上都有一致的行为。</li></ul></li></ul><h3 id="3-编译流程对比"><a href="#3-编译流程对比" class="headerlink" title="3. 编译流程对比"></a>3. <strong>编译流程对比</strong></h3><ul><li><p><strong>Taro 编译流程</strong>：</p><ol><li><strong>解析</strong>：解析 Vue 代码，生成虚拟 DOM 结构。</li><li><strong>逻辑层生成</strong>：生成对应逻辑层代码，处理事件、状态等。</li><li><strong>视图层生成</strong>：将虚拟 DOM 转换为目标平台的原生视图代码（如 <code>wxml</code>）。</li><li><strong>平台适配</strong>：在编译时，根据不同平台的特点调整生成的代码。</li></ol></li><li><p><strong>Uni-app 编译流程</strong>：</p><ol><li><strong>解析</strong>：直接解析 Vue 代码，识别组件、指令等。</li><li><strong>原生代码生成</strong>：将 Vue 组件直接映射为各个平台的原生代码（如小程序的 <code>wxml</code> 和 <code>wxss</code>）。</li><li><strong>API 映射</strong>：将 Vue 中使用的 API 调用映射为对应平台的原生 API。</li><li><strong>适配层处理</strong>：根据目标平台生成适配代码，确保一致性。</li></ol></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>Taro</strong> 的编译过程通过虚拟 DOM 的方式增加了灵活性，但同时引入了额外的性能开销，尤其是在处理复杂状态和事件时。</li><li><strong>Uni-app</strong> 则采用直接映射的方式，将开发者的 Vue 代码转换为原生代码，减少了中间抽象层，通常在性能上更具优势。</li></ul><p><em>这种底层实现的区别影响了框架的性能、开发体验以及在不同平台间的适配能力。在选择时，可以根据具体的项目需求和性能要求进行评估。</em></p><h2 id="运行时区别"><a href="#运行时区别" class="headerlink" title="运行时区别"></a>运行时区别</h2><p>在 Taro 和 Uni-app 这两个框架中，<strong>Taro</strong> 是有运行时（runtime）的，而 <strong>Uni-app</strong> 则没有独立的运行时，主要依赖编译时生成的原生代码。</p><h3 id="1-Taro-的运行时"><a href="#1-Taro-的运行时" class="headerlink" title="1. Taro 的运行时"></a>1. <strong>Taro 的运行时</strong></h3><ul><li><strong>Taro 的运行时作用</strong>：Taro 的核心之一是运行时机制（runtime），这是因为 Taro 需要在不同的平台上模拟 Vue 或 React 的生命周期、事件处理和组件更新。这一运行时主要是在逻辑层执行的，它负责处理虚拟 DOM 的更新、组件状态的管理、事件的冒泡和捕获机制等。Taro 的运行时通过 <code>setData</code> 将逻辑层的数据和状态同步到视图层，并且在视图层渲染出小程序等平台的原生 UI。</li><li><strong>运行时的存在原因</strong>：由于 Taro 是基于虚拟 DOM 实现的，它必须依赖运行时在逻辑层处理虚拟 DOM 操作，并将这些操作同步到不同平台的渲染机制。这也意味着 Taro 在运行时阶段会有额外的性能开销，尤其是在频繁的数据更新和复杂组件交互时。</li></ul><h3 id="2-Uni-app-的无运行时架构"><a href="#2-Uni-app-的无运行时架构" class="headerlink" title="2. Uni-app 的无运行时架构"></a>2. <strong>Uni-app 的无运行时架构</strong></h3><ul><li><strong>Uni-app 的编译时架构</strong>：相比之下，Uni-app 没有类似 Taro 的运行时。Uni-app 通过编译时直接将 Vue 代码转译成各个平台的原生代码（如微信小程序的 <code>wxml</code> 和 <code>wxss</code>），在各个平台的运行时阶段，使用的都是平台的原生渲染引擎和生命周期管理机制。因此，Uni-app 不需要额外的运行时来执行 Vue 组件的更新和渲染逻辑。</li><li><strong>依赖平台的原生运行时</strong>：Uni-app 的设计是为了直接利用平台的原生运行时来处理组件渲染和事件响应。例如，在微信小程序中，Uni-app 编译的代码会直接与微信小程序的原生运行时对接，而不需要像 Taro 那样通过中间的虚拟 DOM 层进行处理。</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>Taro 有运行时</strong>，因为它使用虚拟 DOM 和逻辑层管理机制来适配多平台。这种架构为开发者提供了更灵活的开发体验，但也带来了运行时的性能开销。</li><li><strong>Uni-app 没有独立的运行时</strong>，它依赖于编译时将代码转化为原生平台的代码，并直接利用平台的原生运行时进行渲染和操作，性能开销较小。</li></ul><p>因此，Taro 在不同平台上的代码执行过程会依赖其运行时，而 Uni-app 则是尽可能地依赖各个平台的原生运行机制。</p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>uniapp</tag>
      
      <tag>taro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue自由拖拽vue3-dnd(六)</title>
    <link href="/2024/02/04/vue3-dnd/vue%E8%87%AA%E7%94%B1%E6%8B%96%E6%8B%BDvue3-dnd(%E5%85%AD)/"/>
    <url>/2024/02/04/vue3-dnd/vue%E8%87%AA%E7%94%B1%E6%8B%96%E6%8B%BDvue3-dnd(%E5%85%AD)/</url>
    
    <content type="html"><![CDATA[<h1 id="vue自由拖拽vue3-dnd-六"><a href="#vue自由拖拽vue3-dnd-六" class="headerlink" title="vue自由拖拽vue3-dnd(六)"></a>vue自由拖拽vue3-dnd(六)</h1><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a><a href="https://www.vue3-dnd.com/guide/backend/html5.html#html5">HTML5</a></h2><p>这是由<code>react-dnd</code>主要支持的Backend。它在底层使用了<code>HTML5</code>的<code>Drag</code>和<code>Drop</code>事件。并且处理了<a href="http://quirksmode.org/blog/archives/2009/09/the_html5_drag.html">它的一些问题</a>。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><a href="https://www.vue3-dnd.com/guide/backend/html5.html#%E5%AE%89%E8%A3%85">安装</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install react-dnd-html5-backend<br></code></pre></td></tr></table></figure><h3 id="额外功能"><a href="#额外功能" class="headerlink" title="额外功能"></a><a href="https://www.vue3-dnd.com/guide/backend/html5.html#%E9%A2%9D%E5%A4%96%E5%8A%9F%E8%83%BD">额外功能</a></h3><p>除了导出的<code>Backend</code>，HTML5 Backend 还提供了一些额外的功能:</p><ul><li><code>getEmptyImage()</code>: 它是一个返回透明空图像的函数。用于使用DragSource的<code>dragPreview</code>连接器来完全隐藏浏览器绘制的拖动预览。方便绘制自定义拖动层<code>DragLayer</code>。请注意，自定义拖拽预览在IE中不起作用。</li><li><code>NativeTypes</code>: 三个常量<code>NativeTypes</code>的枚举。<code>NativeTypes.FILE</code>, <code>NativeTypes.URL</code>和 <code>NativeTypes.TEXT</code>。您可以给放置目标指定这些类型，用于处理本地文件、url或常规页面文本的拖拽放置。</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><a href="https://www.vue3-dnd.com/guide/backend/html5.html#%E4%BD%BF%E7%94%A8">使用</a></h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; HTML5Backend &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dnd-html5-backend&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; DndProvider &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue3-dnd&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">DndProvider</span> <span class="hljs-attr">:backend</span>=<span class="hljs-string">&quot;HTML5Backend&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- your drag-and-drop application --&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">DndProvider</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">copy</span><br></code></pre></td></tr></table></figure><p>当你在<code>monitor</code>监视器上调用<code>getItem()</code>时，HTML5 Backend会根据drop类型暴露事件中的各种数据:</p><ul><li><p><code>NativeTypes.FILE:</code></p><ul><li><code>getItem().files</code>, 一个数组，包含拖拽的文件</li><li><code>getItem().items</code>, 使用 <code>event.dataTransfer.items</code>（您可以在删除目录时使用它来列出文件）</li></ul></li><li><p><code>NativeTypes.URL:</code></p><ul><li><code>getItem().url</code>, 一个数组，包含拖拽的 URL</li></ul></li><li><p><code>NativeTypes.TEXT:</code></p><ul><li><code>getItem().text</code>, 拖拽的文本</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue 自由拖拽vue3-dnd(五)</title>
    <link href="/2024/02/04/vue3-dnd/vue%E8%87%AA%E7%94%B1%E6%8B%96%E6%8B%BDvue3-dnd(%E4%BA%94)/"/>
    <url>/2024/02/04/vue3-dnd/vue%E8%87%AA%E7%94%B1%E6%8B%96%E6%8B%BDvue3-dnd(%E4%BA%94)/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-自由拖拽vue3-dnd-五-Monitors"><a href="#vue-自由拖拽vue3-dnd-五-Monitors" class="headerlink" title="vue 自由拖拽vue3-dnd(五)-Monitors"></a>vue 自由拖拽vue3-dnd(五)-<strong>Monitors</strong></h1><h2 id="DragSourceMonitor"><a href="#DragSourceMonitor" class="headerlink" title="DragSourceMonitor"></a><a href="https://www.vue3-dnd.com/guide/monitors/drag-source-monitor.html#dragsourcemonitor">DragSourceMonitor</a></h2><p><code>DragSourceMonitor</code> 是传递给<code>DragSource</code>拖动源的对象。它提供了一些方法，让你可以获取到有关拖动源的一些状态信息。绑定到该监视器的特定拖动源在下面称为监视器的所有者。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a><a href="https://www.vue3-dnd.com/guide/monitors/drag-source-monitor.html#%E6%96%B9%E6%B3%95">方法</a></h3><table><thead><tr><th align="left">方法名</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>canDrag()</code></td><td align="left"><code>() =&gt; boolean</code></td><td align="left">如果没有正在进行的拖动操作，并且所有者<code>useDrag</code>的<code>canDrag()</code>方法返回<code>true</code>或者<code>undefined</code>，则返回<code>true</code>，否则返回<code>false</code>。</td></tr><tr><td align="left"><code>isDragging()</code></td><td align="left"><code>() =&gt; boolean</code></td><td align="left">如果正在进行的拖动操作，并且所有者正在被拖动，或者<code>useDrag</code>的<code>isDragging()</code>方法返回<code>true</code>，该方法就会返回<code>true</code>，否则返回<code>false</code>。</td></tr><tr><td align="left"><code>getItemType()</code></td><td align="left"><code>() =&gt; (string | null)</code></td><td align="left">返回标识当前拖动项的类型<code>type</code>。如果没有项目被拖动，则返回<code>null</code>。</td></tr><tr><td align="left"><code>getItem()</code></td><td align="left"><code>() =&gt; (object | null)</code></td><td align="left">返回表示当前拖动项的普通对象。每个拖动源必须通过从其<code>item</code>属性来指定它。如果没有项目被拖动，则返回<code>null</code>。</td></tr><tr><td align="left"><code>getDropResult()</code></td><td align="left"><code>() =&gt; (object | null)</code></td><td align="left">返回一个表示最后记录的放置结果的普通对象。<br>放置目标可以通过从它们的<code>drop()</code>方法返回一个对象来指定它。<br>当放置目标为嵌套目标时，任何显式地从<code>drop()</code>返回自己的结果的父对象都会覆盖之前由子对象设置的<code>drop</code>结果。<br><strong>它只能在<code>end()</code>内部调用</strong>，如果在<code>end()</code>外部调用，则返回<code>null</code>。</td></tr><tr><td align="left"><code>didDrop()</code></td><td align="left"><code>() =&gt; boolean</code></td><td align="left">如果某个拖放目标已经处理了拖放事件则返回<code>true</code>，否则返回<code>false</code>。即使目标没有返回放置结果，<code>didDrop()</code>也会返回<code>true</code>。 <br>可以在<code>end()</code>中使用它来检查是否有放置目标已经处理了这次拖拽。<br>如果在<code>end()</code>外部调用，则返回<code>false</code>。</td></tr><tr><td align="left"><code>getInitialClientOffset()</code></td><td align="left"><code>() =&gt; &#123; x: number, y: number &#125;</code></td><td align="left">返回当前拖动开始时鼠标指针相对于客户端的初始位置<code>&#123;x, y&#125;</code>。 如果没有项目被拖动，则返回<code>null</code>。</td></tr><tr><td align="left"><code>getInitialSourceClientOffset()</code></td><td align="left"><code>() =&gt; &#123; x: number, y: number &#125;</code></td><td align="left">返回当前拖动开始时，拖动源的根DOM节点相对于客户端的初始位置<code>&#123;x, y&#125;</code>。 如果没有项目被拖动，则返回<code>null</code>。</td></tr><tr><td align="left"><code>getClientOffset()</code></td><td align="left"><code>() =&gt; &#123; x: number, y: number &#125;</code></td><td align="left">返回拖动起始点的鼠标指针相对于客户端的偏移量<code>&#123;x, y&#125;</code>。 如果没有项目被拖动，则返回<code>null</code>。</td></tr><tr><td align="left"><code>getDifferenceFromInitialOffset()</code></td><td align="left"><code>() =&gt; &#123; x: number, y: number &#125;</code></td><td align="left">返回当前拖动中鼠标指针相对于开始拖动时的鼠标指针位置的偏移量<code>&#123;x, y&#125;</code>。 如果没有项目被拖动，则返回<code>null</code>。</td></tr><tr><td align="left"><code>getSourceClientOffset()</code></td><td align="left"><code>() =&gt; &#123; x: number, y: number &#125;</code></td><td align="left">返回当前拖动源的根DOM节点相对于客户端的偏移量<code>&#123;x, y&#125;</code>。 如果没有项目被拖动，则返回<code>null</code>。</td></tr></tbody></table><div class="note note-warning">            <p>注意 ，如果需要获取鼠标的 <strong>实时轨迹</strong> （实时的Offset），应该关注一下 DropTargetMonitor 中的回调，比如 hover</p>          </div><h2 id="DropTargetMonitor"><a href="#DropTargetMonitor" class="headerlink" title="DropTargetMonitor"></a><a href="https://www.vue3-dnd.com/guide/monitors/drop-target-monitor.html#droptargetmonitor">DropTargetMonitor</a></h2><p><code>DropTargetMonitor</code> 是传递给<code>DropTarget</code>放置目标的对象。它提供了一些方法，让你可以获取到有关放置目标的一些状态信息。绑定到该监视器的特定放置目标在下面称为监视器的所有者。</p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a><a href="https://www.vue3-dnd.com/guide/monitors/drop-target-monitor.html#%E6%96%B9%E6%B3%95">方法</a></h3><table><thead><tr><th>方法名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>canDrop()</code></td><td><code>() =&gt; boolean</code></td><td>如果有正在进行的拖动操作，并且所有者<code>useDrop</code>的<code>canDrop()</code>方法返回<code>true</code>或者<code>undefined</code>，则返回<code>true</code>，否则返回<code>false</code>。</td></tr><tr><td><code>isOver()</code></td><td><code>(options?: &#123; shallow: boolean &#125;) =&gt; boolean</code></td><td>如果有正在进行的拖动操作，并且指针当前悬停在所有者的上方，则返回true。你可以选择通过<code>&#123;shallow: true&#125;</code>来严格检查是否只有所有者被悬浮，而不是嵌套的目标。</td></tr><tr><td><code>getItemType()</code></td><td><code>() =&gt; (string | null)</code></td><td>返回标识当前拖动项的类型<code>type</code>。如果没有项目被拖动，则返回<code>null</code>。</td></tr><tr><td><code>getItem()</code></td><td><code>() =&gt; (object | null)</code></td><td>返回表示当前拖动项的普通对象。每个拖动源必须通过从其<code>item</code>属性来指定它。如果没有项目被拖动，则返回<code>null</code>。</td></tr><tr><td><code>getDropResult()</code></td><td><code>() =&gt; (object | null)</code></td><td>返回一个表示最后记录的放置结果的普通对象。 <br>放置目标可以通过从它们的<code>drop()</code>方法返回一个对象来指定它。 <br>当放置目标为嵌套目标时，任何显式地从<code>drop()</code>返回自己的结果的父对象都会覆盖之前由子对象设置的<code>drop</code>结果。 <br><strong>它只能在<code>drop()</code>内部调用</strong>，如果在<code>drop()</code>外部调用，则返回<code>null</code>。</td></tr><tr><td><code>didDrop()</code></td><td><code>() =&gt; boolean</code></td><td>如果某个拖放目标已经处理了拖放事件则返回<code>true</code>，否则返回<code>false</code>。即使目标没有返回放置结果，<code>didDrop()</code>也会返回<code>true</code>。 <br>可以在<code>drop()</code>中使用它来检查是否有放置目标已经处理了这次拖拽。如果在<code>drop()</code>外部调用，则返回<code>false</code>。</td></tr><tr><td><code>getInitialClientOffset()</code></td><td><code>() =&gt; &#123; x: number, y: number &#125;</code></td><td>返回当前拖动开始时鼠标指针相对于客户端的初始位置<code>&#123;x, y&#125;</code>。 <br>如果没有项目被拖动，则返回null。</td></tr><tr><td><code>getInitialSourceClientOffset()</code></td><td><code>() =&gt; &#123; x: number, y: number &#125;</code></td><td>返回当前拖动开始时，拖动源的根DOM节点相对于客户端的初始位置<code>&#123;x, y&#125;</code>。 <br>如果没有项目被拖动，则返回null。</td></tr><tr><td><code>getClientOffset()</code></td><td><code>() =&gt; &#123; x: number, y: number &#125;</code></td><td>返回当前拖动中鼠标指针相对于客户端的偏移量<code>&#123;x, y&#125;</code>。 <br>如果没有项目被拖动，则返回null。</td></tr><tr><td><code>getDifferenceFromInitialOffset()</code></td><td><code>() =&gt; &#123; x: number, y: number &#125;</code></td><td>返回当前拖动中鼠标指针相对于开始拖动时的鼠标指针位置的偏移量<code>&#123;x, y&#125;</code>。 <br>如果没有项目被拖动，则返回null。</td></tr><tr><td><code>getSourceClientOffset()</code></td><td><code>() =&gt; &#123; x: number, y: number &#125;</code></td><td>返回当前拖动源的根DOM节点相对于客户端的偏移量<code>&#123;x, y&#125;</code>。 <br>如果没有项目被拖动，则返回null。</td></tr></tbody></table><h2 id="DragLayerMonitor"><a href="#DragLayerMonitor" class="headerlink" title="DragLayerMonitor"></a><a href="https://www.vue3-dnd.com/guide/monitors/drag-layer-monitor.html#draglayermonitor">DragLayerMonitor</a></h2><p><code>DragLayerMonitor</code> 是传递给<code>DragLayer</code>拖动层<code>collect</code>收集函数的对象。它提供了一些方法，让你可以获取到全局拖放状态信息。</p><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a><a href="https://www.vue3-dnd.com/guide/monitors/drag-layer-monitor.html#%E6%96%B9%E6%B3%95">方法</a></h3><table><thead><tr><th>方法名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>isDragging()</code></td><td><code>() =&gt; boolean</code></td><td>如果正在进行的拖动操作，并且所有者正在被拖动，或者<code>useDrag</code>的<code>isDragging()</code>方法返回<code>true</code>，该方法就会返回<code>true</code>，否则返回<code>false</code>。</td></tr><tr><td><code>getItemType()</code></td><td><code>() =&gt; (string | null)</code></td><td>返回标识当前拖动项的类型<code>type</code>。如果没有项目被拖动，则返回<code>null</code>。</td></tr><tr><td><code>getItem()</code></td><td><code>() =&gt; (object | null)</code></td><td>返回表示当前拖动项的普通对象。每个拖动源必须通过从其<code>item</code>属性来指定它。如果没有项目被拖动，则返回<code>null</code>。</td></tr><tr><td><code>getInitialClientOffset()</code></td><td><code>() =&gt; &#123; x: number, y: number &#125;</code></td><td>返回当前拖动开始时鼠标指针相对于客户端的初始位置<code>&#123;x, y&#125;</code>。 <br>如果没有项目被拖动，则返回null。</td></tr><tr><td><code>getInitialSourceClientOffset()</code></td><td><code>() =&gt; &#123; x: number, y: number &#125;</code></td><td>返回当前拖动开始时，拖动源的根DOM节点相对于客户端的初始位置<code>&#123;x, y&#125;</code>。 <br>如果没有项目被拖动，则返回null。</td></tr><tr><td><code>getClientOffset()</code></td><td><code>() =&gt; &#123; x: number, y: number &#125;</code></td><td>返回当前拖动中鼠标指针相对于客户端的偏移量<code>&#123;x, y&#125;</code>。 <br>如果没有项目被拖动，则返回null。</td></tr><tr><td><code>getDifferenceFromInitialOffset()</code></td><td><code>() =&gt; &#123; x: number, y: number &#125;</code></td><td>返回当前拖动中鼠标指针相对于开始拖动时的鼠标指针位置的偏移量<code>&#123;x, y&#125;</code>。 <br>如果没有项目被拖动，则返回null。</td></tr><tr><td><code>getSourceClientOffset()</code></td><td><code>() =&gt; &#123; x: number, y: number &#125;</code></td><td>返回当前拖动源的根DOM节点相对于客户端的偏移量<code>&#123;x, y&#125;</code>。 <br>如果没有项目被拖动，则返回null。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue 自由拖拽vue3-dnd(四)</title>
    <link href="/2024/02/02/vue3-dnd/vue%E8%87%AA%E7%94%B1%E6%8B%96%E6%8B%BDvue3-dnd(%E5%9B%9B)/"/>
    <url>/2024/02/02/vue3-dnd/vue%E8%87%AA%E7%94%B1%E6%8B%96%E6%8B%BDvue3-dnd(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-自由拖拽vue3-dnd-四-Composition-API"><a href="#vue-自由拖拽vue3-dnd-四-Composition-API" class="headerlink" title="vue 自由拖拽vue3-dnd(四)-Composition API"></a>vue 自由拖拽vue3-dnd(四)-Composition API</h1><p>提供了三个主要的钩子来将你的组件连接到 Vue3 DnD。并且提供了第四个钩子来让你在开发或测试中连接到 Vue3 DnD。</p><ul><li><code>useDrag</code></li><li><code>useDrop</code></li><li><code>useDragLayer</code></li><li><code>useDragDropManager</code>（开发&#x2F;测试挂钩）</li></ul><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a><a href="https://www.vue3-dnd.com/guide/composition/#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B">基本示例</a></h2><p>使用 composition api 制作一个简单的可以拖放的盒子。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; useDrag &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue3-dnd&#x27;</span></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; toRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@vueuse/core&quot;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> [collect, drag, dragPreview] = <span class="hljs-title function_">useDrag</span>(<span class="hljs-function">() =&gt;</span> (&#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// “type”是必需的。它由放置目标的“accept”使用。</span></span><br><span class="language-javascript">    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BOX&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-comment">// collect 函数传入一个“监视器”实例，用于从 DnD 中获取需要的状态信息。</span></span><br><span class="language-javascript">    <span class="hljs-attr">collect</span>: <span class="hljs-function">(<span class="hljs-params">monitor</span>) =&gt;</span> (&#123;</span><br><span class="language-javascript">      <span class="hljs-attr">isDragging</span>: monitor.<span class="hljs-title function_">isDragging</span>()</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">  &#125;))</span><br><span class="language-javascript">  <span class="hljs-comment">// collect是一个Ref对象，默认取值需要从collect.value中获取,</span></span><br><span class="language-javascript">  <span class="hljs-comment">// 可以使用toRefs将Ref对象转换为可解构的对象</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> &#123; isDragging &#125; = <span class="hljs-title function_">toRefs</span>(collect)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 这是可选的。默认情况下，dragPreview 将附加到 dragSource --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:ref</span>=<span class="hljs-string">&quot;dragPreview&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; opacity: isDragging ? 0.5 : 1 &#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;Handle&quot;</span> <span class="hljs-attr">:ref</span>=<span class="hljs-string">&quot;drag&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接下来，我们需要一个放置目标。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123;useDrop&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue3-dnd&#x27;</span></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123;toRefs&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vueuse/core&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> [collect, drop] = <span class="hljs-title function_">useDrop</span>(<span class="hljs-function">() =&gt;</span> (&#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// 允许放置的type(string|symbol)，或者types</span></span><br><span class="language-javascript">    <span class="hljs-attr">accept</span>: <span class="hljs-string">&#x27;BOX&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-comment">// 传递个collect的数据</span></span><br><span class="language-javascript">    <span class="hljs-attr">collect</span>: <span class="hljs-function"><span class="hljs-params">monitor</span> =&gt;</span> (&#123;</span><br><span class="language-javascript">      <span class="hljs-attr">isOver</span>: monitor.<span class="hljs-title function_">isOver</span>(),</span><br><span class="language-javascript">      <span class="hljs-attr">canDrop</span>: monitor.<span class="hljs-title function_">canDrop</span>(),</span><br><span class="language-javascript">    &#125;),</span><br><span class="language-javascript">  &#125;))</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> &#123;canDrop, isOver&#125; = <span class="hljs-title function_">toRefs</span>(collect)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:ref</span>=<span class="hljs-string">&quot;drop&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; backgroundColor: isOver ? &#x27;red&#x27; : &#x27;white&#x27; &#125;&quot;</span>&gt;</span><br>    &#123;&#123; canDrop ? &#x27;Release to drop&#x27; : &#x27;Drag a box here&#x27; &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样我们就实现了一个拖拽的盒子，你可以接着阅读单独的 API 文档，或者查看 <a href="https://www.vue3-dnd.com/example/">示例</a>。</p><h2 id="useDrag"><a href="#useDrag" class="headerlink" title="useDrag"></a><a href="https://www.vue3-dnd.com/guide/composition/use-drag.html#usedrag">useDrag</a></h2><p><code>useDrag</code> 函数提供了一种将你的组件作为 <strong>拖拽源</strong> 连接到 DnD 的方法。它接收一个 <code>Specification</code>，你可以通过 <code>type</code> 指定拖拽的类型，通过 <code>item</code> 表示拖动源的数据，通过 <code>collect</code> 获取拖拽状态等等。</p><p><code>useDrag</code> 返回了三个值：<code>collect</code> 函数的返回值，<code>dragSource</code> 和 <code>dragPreview</code> 的连接器函数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; useDrag &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue3-dnd&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> [collectedProps, dragSource, dragPreview] = <span class="hljs-title function_">useDrag</span>(<span class="hljs-function">() =&gt;</span> (&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BOX&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">item</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;1&#x27;</span> &#125;,</span><br><span class="language-javascript">  &#125;))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;collectedProps.isDragging&quot;</span> <span class="hljs-attr">:ref</span>=<span class="hljs-string">&quot;dragPreview&quot;</span>&gt;</span>dragPreview<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">:ref</span>=<span class="hljs-string">&quot;dragSource&quot;</span>&gt;</span>dragSource<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a><a href="https://www.vue3-dnd.com/guide/composition/use-drag.html#%E5%8F%82%E6%95%B0">参数</a></h3><p><code>useDrag</code> 的参数可以是一个 <code>Specification</code> 对象，也可以是一个函数，返回一个 <code>Specification</code> 对象，有关 <code>Specification</code> 的详细信息，请参考 <a href="https://www.vue3-dnd.com/guide/composition/use-drag.html#specification-%E5%AF%B9%E8%B1%A1">Specification</a>。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a><a href="https://www.vue3-dnd.com/guide/composition/use-drag.html#%E8%BF%94%E5%9B%9E%E5%80%BC">返回值</a></h3><p><code>useDrag</code> 返回一个数组，包含三个值：<code>collect</code> 函数的返回值，<code>dragSource</code> 和 <code>dragPreview</code> 的连接器函数</p><ul><li><code>[0] -  Collected Props</code></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">object</span>&gt;<br></code></pre></td></tr></table></figure><ul><li><p>它是一个 <code>Ref</code> 对象，它的 <code>value</code> 指向 <code>collect</code> 函数的返回值，如果没有定义 <code>collect</code> 函数，它的 <code>value</code> 就是一个空对象</p></li><li><p><code>[1] -  DragSource Connector</code></p></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">(<span class="hljs-attr">el</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-title class_">HTMLElement</span>&gt; | <span class="hljs-title class_">HTMLElement</span>, <span class="hljs-attr">options</span>?: <span class="hljs-title class_">DragSourceOptions</span>) =&gt; <span class="hljs-title class_">HTMLElement</span><br></code></pre></td></tr></table></figure><ul><li><p>拖拽源的连接器函数。<strong>它必须被调用</strong>，并且传入一个 <code>Ref&lt;HTMLElement&gt; | HTMLElement</code> 的可拖拽 DOM 元素；</p></li><li><p>第二个参数是一个 options 对象，与 Specification 对象的 options 一致</p></li><li><p><code>[2] - DragPreview Connector</code></p></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">(<span class="hljs-attr">el</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-title class_">HTMLElement</span>&gt; | <span class="hljs-title class_">HTMLElement</span>, <span class="hljs-attr">options</span>?: <span class="hljs-title class_">DragPreviewOptions</span>) =&gt; <span class="hljs-title class_">HTMLElement</span><br></code></pre></td></tr></table></figure><ul><li><p>拖拽预览的连接器函数。它是可选的，<strong>默认使用 dragSource 作为预览元素</strong>，接收一个 <code>Ref&lt;HTMLElement&gt; | HTMLElement</code> 的可拖拽 DOM 元素；</p></li><li><p>第二个参数是一个 options 对象，与 Specification 对象的 previewOptions 一致</p></li></ul><h3 id="Specification-对象"><a href="#Specification-对象" class="headerlink" title="Specification 对象"></a><a href="https://www.vue3-dnd.com/guide/composition/use-drag.html#specification-%E5%AF%B9%E8%B1%A1">Specification 对象</a></h3><p>在了解 <code>Specification</code> 对象的基本用法之前，你可能需要先了解一下 <a href="https://www.vue3-dnd.com/guide/monitors/drag-source-monitor.html">DragSourceMonitor</a> 对象。</p><table><thead><tr><th align="left">Key</th><th>必填</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">type</td><td>是</td><td align="left"><code>string | symbol</code></td><td align="left">拖拽元素的类型</td></tr><tr><td align="left">item</td><td>是</td><td align="left"><code>object | () =&gt; object</code></td><td align="left">对象时，它是一个描述被拖动数据的纯 JavaScript 对象。<br> 这是拖放目标唯一可用的关于拖动源的信息，因此选择他们需要知道的最少数据很重要。<br> 您可能很想在此处放置一个复杂的引用，但您应该尽量避免这样做，因为它会耦合拖动源和放置目标。使用类似的东西是个好主意 <code>&#123; id &#125;</code>。<br/> 函数时，它在拖动操作开始时被触发并返回一个表示拖动操作的对象。如果返回 <code>null</code>，则取消拖动操作。</td></tr><tr><td align="left">collect</td><td>否</td><td align="left"><code>(monitor: DragSourceMonitor) =&gt; CollectedProps</code></td><td align="left">一个收集器的函数。它应该返回一个普通对象并成为 <code>useDrag</code> 返回值中的第一个项。</td></tr><tr><td align="left">previewOptions</td><td>否</td><td align="left"><code>DragPreviewOptions</code></td><td align="left">一个描述拖动预览选项的纯 JavaScript 对象。</td></tr><tr><td align="left">options</td><td>否</td><td align="left"><code>DragSourceOptions</code></td><td align="left">一个普通对象，可选地包含以下任何属性：<br> <code>dropEffect</code>: 非必填，在此拖动中使用的拖放效果类型。可选值：&#96;’move’</td></tr><tr><td align="left">end</td><td>否</td><td align="left"><code>(draggedItem: object, monitor: DragSourceMonitor) =&gt; void</code></td><td align="left">当拖动停止时，<code>end</code> 函数会被调用。<br> 你可以调用 <code>monitor.didDrop()</code> 以检查本次拖拽是否成功; <br> 如果它成功，并且放置目标通过从其 <code>drop()</code> 方法返回一个普通对象来指定放置结果，那么它将作为 <code>monitor.getDropResult()</code> 的返回值。<br> 这个方法是处理数据变化的好地方。</td></tr><tr><td align="left">canDrag</td><td>否</td><td align="left"><code>boolean | (monitor: DragSourceMonitor) =&gt; boolean</code></td><td align="left">你可以使用它来指定当前是否允许拖动。默认为 <code>true</code>。<br> 如果您想禁用基于某些条件的拖动，则指定一个函数会很便捷。<br> 注意：你不能在这个方法内部调用 <code>monitor.canDrag()</code>。</td></tr><tr><td align="left">isDragging</td><td>否</td><td align="left"><code>boolean | (monitor: DragSourceMonitor) =&gt; boolean</code></td><td align="left">默认情况下，只有发起拖动操作的拖动源才被认为是拖动的。<br> 你可以通过定义自定义一个 <code>isDragging</code> 方法来覆盖此行为。<br> 它可能会返回类似 <code>props.id === monitor.getItem().id</code>。<br> 注意：你不能在这个方法内部调用 <code>monitor.isDragging()</code>。</td></tr></tbody></table><h2 id="useDrop"><a href="#useDrop" class="headerlink" title="useDrop"></a><a href="https://www.vue3-dnd.com/guide/composition/use-drop.html#usedrop">useDrop</a></h2><p><code>useDrop</code> 函数提供了一种将你的组件作为 <strong>放置目标</strong> 连接到 DnD 的方法。它接收一个 <code>Specification</code>，你可以通过 <code>accpet</code> 指定允许放置的类型，通过 <code>item</code> 表示拖动源的数据，通过 <code>collect</code> 获取拖拽状态等等。</p><p><code>useDrop</code> 返回了两个值：<code>collect</code> 函数的返回值，<code>dropTarget</code> 的连接器函数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; useDrop &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue3-dnd&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> [collectedProps, drop] = <span class="hljs-title function_">useDrop</span>(<span class="hljs-function">() =&gt;</span> (&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">accept</span>: [<span class="hljs-string">&#x27;BOX&#x27;</span>]</span><br><span class="language-javascript">  &#125;))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:ref</span>=<span class="hljs-string">&quot;drop&quot;</span>&gt;</span>Drop Target<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a><a href="https://www.vue3-dnd.com/guide/composition/use-drop.html#%E5%8F%82%E6%95%B0">参数</a></h3><p><code>useDrop</code> 的参数可以是一个 <code>Specification</code> 对象，也可以是一个函数，返回一个 <code>Specification</code> 对象，有关 <code>Specification</code> 的详细信息，请参考 <a href="https://www.vue3-dnd.com/guide/composition/use-drop.html#specification-%E5%AF%B9%E8%B1%A1">Specification</a>。</p><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a><a href="https://www.vue3-dnd.com/guide/composition/use-drop.html#%E8%BF%94%E5%9B%9E%E5%80%BC">返回值</a></h3><p><code>useDrop</code> 返回一个数组，包含两个值：<code>collect</code> 函数的返回值，<code>dropTarget</code> 的连接器函数</p><ul><li><p><code>[0] - Collected Props</code></p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">object</span>&gt;<br></code></pre></td></tr></table></figure><ul><li>它是一个 <code>Ref</code> 对象，它的 <code>value</code> 指向 <code>collect</code> 函数的返回值，如果没有定义 <code>collect</code> 函数，它的 <code>value</code> 就是一个空对象</li></ul></li><li><p><code>[1] - DragTarget Connector</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">Ref</span>&lt;<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">el</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-title class_">HTMLElement</span>&gt; | <span class="hljs-title class_">HTMLElement</span></span>) =&gt;</span> <span class="hljs-title class_">HTMLElement</span>&gt;<br></code></pre></td></tr></table></figure><ul><li><p>放置目标的连接器函数。<strong>它必须被调用</strong>，并且传入一个 <code>Ref&lt;HTMLElement&gt; | HTMLElement</code> 的可被拖放 DOM 元素；</p></li><li><p>第二个参数是一个 options 对象，与 Specification 对象的 options 一致</p></li></ul></li></ul><h3 id="Specification-对象-1"><a href="#Specification-对象-1" class="headerlink" title="Specification 对象"></a><a href="https://www.vue3-dnd.com/guide/composition/use-drop.html#specification-%E5%AF%B9%E8%B1%A1">Specification 对象</a></h3><p>在了解 <code>Specification</code> 对象的基本用法之前，你可能需要先了解一下 <a href="https://www.vue3-dnd.com/guide/monitors/drop-target-monitor.html">DropTargetMonitor</a> 对象。</p><table><thead><tr><th align="left">Key</th><th>必填</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td align="left">accept</td><td>是</td><td><code>string | symbol | string[] | symbol[]</code></td><td>此放置目标只会对 <a href="https://www.vue3-dnd.com/guide/composition/use-drag.html">指定类型的拖动源</a> 做出反应。</td></tr><tr><td align="left">collect</td><td>否</td><td><code>(monitor: DropTargetMonitor) =&gt; CollectedProps</code></td><td>一个收集器的函数。<br> 它应该返回一个普通对象并成为 <code>useDrop</code> 返回值中的第一个项。</td></tr><tr><td align="left">options</td><td>否</td><td><code>object</code></td><td>目前没什么用。</td></tr><tr><td align="left">drop</td><td>否</td><td><code>(item: object, monitor: DropTargetMonitor) =&gt; (void | Record&lt;string, any&gt;)</code></td><td>当拖拽元素放置在目标上时调用。你可以不返回任何东西，也可以返回一个普通对象。<br> 如果你返回了一个对象，它将成为 <code>dropResult</code>, 并且在 <code>drag</code> 的 <code>end</code> 方法中，可以通过 <code>monitor.getDropResult()</code> 获取到它。<br> 如果你想根据不同的放置目标执行不同的操作，这将是一个不错的选择。<br> 如果你的放置目标是嵌套的，那你可以通过 <code>monitor.didDrop()</code> 和 <code>monitor.getDropResult()</code> 来检查嵌套目标是否已经处理。 这个方法和 <code>drag</code> 的 <code>end</code> 方法，都是处理数据变化的好地方。<br> 如果 <code>canDrop()</code> 方法返回 <code>false</code>，则不会调用此方法。</td></tr><tr><td align="left">hover</td><td>否</td><td><code>(item: object, monitor: DropTargetMonitor) =&gt; void</code></td><td>当拖拽组件经过组件上时调用该方法。 你可以通过检查 <code>monitor.isOver(&#123; shallow: true &#125;)</code> 来检查悬停是仅发生在当前目标上还是发生在内部的嵌套目标上。 和 <code>drop()</code> 方法不同的是：即使 <code>canDrop()</code> 返回了 <code>false</code>，该方法也会被调用。 你可以通过 <code>monitor.canDrop()</code> 来确认并避免这种情况。</td></tr><tr><td align="left">canDrop</td><td>否</td><td><code>(item: DragObject, monitor: DropTargetMonitor&lt;DragObject, DropResult&gt;) =&gt; boolean</code></td><td>用于指定放置目标是否能够接受此拖拽组件。<br> 如果你希望总是允许，请忽略该方法。<br> 如果你想基于 <code>props</code> 或 <code>monitor.getItem()</code> 中的某些断言禁用放置，就可以使用它。<br> 注意：你不能在这个方法中调用 <code>monitor.canDrop()</code>。</td></tr></tbody></table><h2 id="useDragLayer"><a href="#useDragLayer" class="headerlink" title="useDragLayer"></a><a href="https://www.vue3-dnd.com/guide/composition/use-drag-layer.html#usedraglayer">useDragLayer</a></h2><p><code>useDragLayer</code> 函数提供了一种将你的组件作为 <strong>拖动层</strong> 连接到 DnD 的方法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; useDragLayer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue3-dnd&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> collectedProps = <span class="hljs-title function_">useDragLayer</span>(<span class="hljs-function"><span class="hljs-params">monitor</span> =&gt;</span> (&#123; </span><br><span class="language-javascript">    <span class="hljs-attr">item</span>: monitor.<span class="hljs-title function_">getItem</span>(),</span><br><span class="language-javascript">  &#125;))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a><a href="https://www.vue3-dnd.com/guide/composition/use-drag-layer.html#%E5%8F%82%E6%95%B0">参数</a></h3><p><code>useDragLayer</code> 的参数是一个 <code>collect</code> 收集函数，它应该返回一个普通对象，并使你在组件中使用。</p><p><code>collect</code> 收集函数的参数是一个 <a href="https://www.vue3-dnd.com/guide/monitors/drag-layer-monitor.html">DragLayerMonitor</a> 对象，它提供了一些监视器的方法，以便你可以获取监视器的状态。<code>collect</code> 函数的类型如下:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">(<span class="hljs-attr">monitor</span>: <span class="hljs-title class_">DragLayerMonitor</span>) =&gt; (<span class="hljs-built_in">void</span> | <span class="hljs-built_in">object</span>)<br></code></pre></td></tr></table></figure><h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a><a href="https://www.vue3-dnd.com/guide/composition/use-drag-layer.html#%E8%BF%94%E5%9B%9E%E5%80%BC">返回值</a></h3><p><code>useDragLayer</code> 返回一个 <code>Ref</code> 对象，它是 <code>collect</code> 函数的返回值。</p> <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">Collected</span> <span class="hljs-title class_">Props</span> - <span class="hljs-title class_">Ref</span> &lt;<span class="hljs-built_in">object</span>&gt;<br></code></pre></td></tr></table></figure><ul><li>它是一个<code>Ref</code>对象，它的<code>value</code>指向<code>collect</code>函数的返回值。</li></ul>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue自由拖拽vue3-dnd(三)</title>
    <link href="/2024/02/02/vue3-dnd/vue%E8%87%AA%E7%94%B1%E6%8B%96%E6%8B%BDvue3-dnd(%E4%B8%89)/"/>
    <url>/2024/02/02/vue3-dnd/vue%E8%87%AA%E7%94%B1%E6%8B%96%E6%8B%BDvue3-dnd(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-自由拖拽vue3-dnd-三-组件"><a href="#vue-自由拖拽vue3-dnd-三-组件" class="headerlink" title="vue 自由拖拽vue3-dnd(三)-组件"></a>vue 自由拖拽vue3-dnd(三)-组件</h1><p>接下来就进入正题了，该如何使用，请看以下说明：</p><h2 id="DndProvider"><a href="#DndProvider" class="headerlink" title="DndProvider"></a><a href="https://www.vue3-dnd.com/guide/components/dnd-provider.html#dndprovider">DndProvider</a></h2><p><code>DndProvider</code> 组件为您的应用程序提供 Vue3 DnD 功能。它必须通过<code>backend</code>这个prop注入一个Backend。</p><p>一般我们在App.vue文件中使用它。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a><a href="https://www.vue3-dnd.com/guide/components/dnd-provider.html#%E7%94%A8%E6%B3%95">用法</a></h3><h4 id="PC-端"><a href="#PC-端" class="headerlink" title="PC 端"></a><a href="https://www.vue3-dnd.com/guide/components/dnd-provider.html#pc%E7%AB%AF">PC 端</a></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">DndProvider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue3-dnd&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">HTML5Backend</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dnd-html5-backend&#x27;</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">DndProvider</span> <span class="hljs-attr">:backend</span>=<span class="hljs-string">&quot;HTML5Backend&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Your Drag-and-Drop Application --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">DndProvider</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a><a href="https://www.vue3-dnd.com/guide/components/dnd-provider.html#%E7%A7%BB%E5%8A%A8%E7%AB%AF">移动端</a></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">DndProvider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue3-dnd&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">TouchBackend</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dnd-touch-backend&#x27;</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">DndProvider</span> <span class="hljs-attr">:backend</span>=<span class="hljs-string">&quot;TouchBackend&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Your Drag-and-Drop Application --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">DndProvider</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a><a href="https://www.vue3-dnd.com/guide/components/dnd-provider.html#props">Props</a></h3><table><thead><tr><th>参数</th><th>说明</th><th>类型</th><th>是否必填</th></tr></thead><tbody><tr><td>backend</td><td>一个 React DnD 的 Backend</td><td>Backend</td><td>是</td></tr><tr><td>context</td><td>用于配置 Backend 的上下文对象; 这取决于 Backend 实现。</td><td>object</td><td>否</td></tr><tr><td>options</td><td>用于配置 Backend 的选项对象; 这取决于 Backend 实现。</td><td>object</td><td>否</td></tr></tbody></table><h2 id="DragPreviewImage"><a href="#DragPreviewImage" class="headerlink" title="DragPreviewImage"></a><a href="https://www.vue3-dnd.com/guide/components/drag-preview-image.html#dragpreviewimage">DragPreviewImage</a></h2><p>将 HTML Image 元素呈现为拖动预览的组件。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a><a href="https://www.vue3-dnd.com/guide/components/drag-preview-image.html#%E7%94%A8%E6%B3%95">用法</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">DragPreviewImage</span>, useDrag &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue3-dnd&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> [collect, drag, dragPreview] = <span class="hljs-title function_">useDrag</span>(<span class="hljs-function">() =&gt;</span> (&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Box&#x27;</span>,</span><br><span class="language-javascript">&#125;))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">DragPreviewImage</span> <span class="hljs-attr">:connect</span>=<span class="hljs-string">&quot;dragPreview&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;house_dragged.png&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:ref</span>=<span class="hljs-string">&quot;drag&quot;</span>&gt;</span>🏠<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Props-1"><a href="#Props-1" class="headerlink" title="Props"></a><a href="https://www.vue3-dnd.com/guide/components/drag-preview-image.html#props">Props</a></h3><table><thead><tr><th>参数</th><th>说明</th><th>类型</th><th>是否必填</th></tr></thead><tbody><tr><td>src</td><td>图片的src</td><td>string</td><td>是</td></tr><tr><td>connect</td><td><code>dragPreview</code>连接器</td><td>function</td><td>是</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue自由拖拽vue3-dnd(二)</title>
    <link href="/2024/01/31/vue3-dnd/vue%E8%87%AA%E7%94%B1%E6%8B%96%E6%8B%BDvue3-dnd(%E4%BA%8C)/"/>
    <url>/2024/01/31/vue3-dnd/vue%E8%87%AA%E7%94%B1%E6%8B%96%E6%8B%BDvue3-dnd(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-自由拖拽vue3-dnd-二-基础"><a href="#vue-自由拖拽vue3-dnd-二-基础" class="headerlink" title="vue 自由拖拽vue3-dnd(二)-基础"></a>vue 自由拖拽vue3-dnd(二)-基础</h1><h2 id="react-dnd-基础概念"><a href="#react-dnd-基础概念" class="headerlink" title="react-dnd 基础概念"></a>react-dnd 基础概念</h2><h3 id="项目-Items-和-类型-Types"><a href="#项目-Items-和-类型-Types" class="headerlink" title="项目(Items) 和 类型(Types)"></a>项目(Items) 和 类型(Types)</h3><ul><li>React DnD <strong>使用数据</strong> 而不是视图作为拖拽实施。</li><li>在屏幕上拖动某些东西时，称为正在拖动某种类型的项目。</li><li>项目是描述被拖动内容的 <strong>纯 JavaScript 对象</strong>。</li><li>类型是一个字符串（或一个符号），用于 <strong>唯一标识</strong> 应用程序中的一整类项目。</li><li>类型很有用，因为随着项目的庞大，你可能希望更多的东西可拖动，但你不一定希望所有现有的放置目标突然可以接收新项目的放置。<strong>类型让你可以指定拖放源和拖放目标</strong>。</li></ul><h3 id="监视器-Monitors"><a href="#监视器-Monitors" class="headerlink" title="监视器(Monitors)"></a>监视器(Monitors)</h3><p>拖放本质上是有状态的。拖动操作正在进行中，或者没有。要么有当前类型和当前项目，要么没有。这种状态必须存在于某个地方。</p><p>对于每个需要跟踪拖放状态的组件，您可以定义一个收集函数，从监视器中提取状态。</p><p>假设你想在拖动棋子的时候突出显示允许放置的 Cell 单元格，组件 Cell 的收集函数可能如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> [collect, drop] = <span class="hljs-title function_">useDrop</span>(&#123;<br>  <span class="hljs-attr">accept</span>: <span class="hljs-string">&#x27;Cell&#x27;</span>,<br>  <span class="hljs-attr">collect</span>: <span class="hljs-function"><span class="hljs-params">monitor</span> =&gt;</span> (&#123;<br>    <span class="hljs-attr">canDrop</span>: monitor.<span class="hljs-title function_">canDrop</span>(),<br>    <span class="hljs-attr">hovered</span>: monitor.<span class="hljs-title function_">isOver</span>(),<br>  &#125;),<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>canDrop 表示拖动元素可以放置到当前元素，hovered 表示拖动元素正在当前元素上</p><h3 id="拖拽源-Drag-Sources-和-拖放目标-Drop-Targets"><a href="#拖拽源-Drag-Sources-和-拖放目标-Drop-Targets" class="headerlink" title="拖拽源(Drag Sources) 和 拖放目标 (Drop Targets)"></a>拖拽源(Drag Sources) 和 拖放目标 (Drop Targets)</h3><ul><li>使用拖拽源 dragSource 来表示拖拽的元素</li><li>使用拖放目标 drop 来表示目标接收拖拽元素</li></ul><h3 id="Backend"><a href="#Backend" class="headerlink" title="Backend"></a>Backend</h3><ul><li>Backend 抽象出了浏览器的差异并处理原生 DOM 事件。</li><li>所有 Backend 所做的就是将 DOM 事件转换为 React DnD 可以处理的内部 Redux 操作。</li><li>受益于 React DnD 的设计，vue3-dnd 直接采用它的 HTML5 Backend , Touch Backend 和 Test Backend ，甚至是一些自定义的 Backend</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>相信您已经理解了 React DnD 的一部分核心概念, 加详细的介绍可以参考 <a href="https://react-dnd.github.io/react-dnd/docs/overview">React DnD 概述</a></p><div class="note note-success">            <p><strong>后续我会讲一些基础的用法，尽请期待</strong></p>          </div>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue自由拖拽vue3-dnd(一)</title>
    <link href="/2024/01/31/vue3-dnd/vue%E8%87%AA%E7%94%B1%E6%8B%96%E6%8B%BDvue3-dnd(%E4%B8%80)/"/>
    <url>/2024/01/31/vue3-dnd/vue%E8%87%AA%E7%94%B1%E6%8B%96%E6%8B%BDvue3-dnd(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="vue自由拖拽vue3-dnd-一-概述"><a href="#vue自由拖拽vue3-dnd-一-概述" class="headerlink" title="vue自由拖拽vue3-dnd(一)-概述"></a>vue自由拖拽vue3-dnd(一)-概述</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作中碰到需要频繁使用拖拽功能，调研了vue3的dragable发现功能还是太简单了，像是一个简单的拖拽排序库，不是很满足需求。这里我要说react的拖拽库就有很多选择，这点确实vue3还需要努力。既然vue3找不到，那有没有react移植过来的呢？我一搜，还真有！就是今天的主角<a href="https://github.com/hcg1023/vue3-dnd">vue3-dnd</a>。</p><p>这个库是react的<a href="https://github.com/react-dnd/react-dnd">React DnD</a>的vue移植版本。</p><h2 id="Vue3-DnD"><a href="#Vue3-DnD" class="headerlink" title="Vue3 DnD"></a>Vue3 DnD</h2><p><a href="https://github.com/hcg1023/vue3-dnd">vue3-dnd</a>是基于React DnD的核心程序实现的一组Vue composition-api，它提供了尽量与React DnD保持一致的api，便于我们去构建一个复杂、自由的拖拽功能。下面将介绍一下它的基础信息。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装</span><br>pnpm install vue3-dnd react-dnd-html5-backend<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>npm install vue3-dnd react-dnd-html5-backend<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>yarn add vue3-dnd react-dnd-html5-backend<br></code></pre></td></tr></table></figure><p>react-dnd-html5-backend 是一个React DnD 的插件，它提供了一个HTML5的拖放支持；你也可以使用react-dnd-touch-backend 提供触摸拖放支持。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h4><p>基于Vue的组合式API，你可以在任何组件中使用拖拽。</p><h4 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h4><p>基于Vue的双向数据绑定，你可以在数据更新时自动更新UI。</p><h4 id="支持Vue2和Vue3"><a href="#支持Vue2和Vue3" class="headerlink" title="支持Vue2和Vue3"></a>支持Vue2和Vue3</h4><p>同时支持Vue2和Vue3两个版本</p><h5 id="支持Vue2"><a href="#支持Vue2" class="headerlink" title="支持Vue2"></a>支持Vue2</h5><p>由于Vue2的一些特性，在Vue2中使用还有一点细微的差别：</p><ol><li>在Vue&lt;&#x3D;2.6中使用，需要先安装@vue&#x2F;composition-api</li><li>由于Vue2不支持dom ref函数，所以我们必须额外定义一个ref，用于承载dom节点，并将这个ref传递给我们的connect函数。</li></ol><p>以下是一个示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span><br><span class="hljs-tag">        <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;element&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;Box&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">:data-testid</span>=<span class="hljs-string">&quot;`box-$&#123;name&#125;`&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br>        &#123;&#123; name &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; useDrag &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue3-dnd&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vue/composition-api&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">interface <span class="hljs-title class_">DropResult</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: string</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> props = defineProps&lt;&#123; <span class="hljs-attr">name</span>: string &#125;&gt;()</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> [collect, drag, dragPreview] = <span class="hljs-title function_">useDrag</span>(<span class="hljs-function">() =&gt;</span> (&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BOX&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">item</span>: &#123; <span class="hljs-attr">name</span>: props.<span class="hljs-property">name</span> &#125;,</span><br><span class="language-javascript">&#125;))</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> element = <span class="hljs-title function_">ref</span>()</span><br><span class="language-javascript"><span class="hljs-title function_">drag</span>(element)</span><br><span class="language-javascript"><span class="hljs-comment">// 可选的，默认与drag一致</span></span><br><span class="language-javascript"><span class="hljs-comment">// dragPreview(element)</span></span><br><span class="language-javascript"><span class="hljs-comment">// 如果是useDrop，也是一样的</span></span><br><span class="language-javascript"><span class="hljs-comment">// drop(element)</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="扩展和测试"><a href="#扩展和测试" class="headerlink" title="扩展和测试"></a>扩展和测试</h4><p>受益于React DnD的backend设计，你可以自定义一个DnD backend，并且可以使用 react-dnd-test-backend 测试你的拖拽组件。</p><div class="note note-success">            <p><strong>后续我会讲一些react-dnd的基础概念，尽请期待</strong></p>          </div>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建一个博客</title>
    <link href="/2023/09/04/hexo/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/09/04/hexo/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p><a href="https://link.juejin.cn/?target=https://hexo.io/zh-cn/docs/" title="https:&#x2F;&#x2F;hexo.io&#x2F;zh-cn&#x2F;docs&#x2F;">Hexo</a>是一个开源的静态博客框架，具有快速、简洁和高效的特点。<code>Hexo</code> 使用 <code>Markdown</code>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 <code>GitHub</code>是一个广泛用于代码托管和版本控制的平台，提供了免费的 <code>GitHub Pages</code>功能，可以用于托管个人博客。结合 <code>Hexo</code>和 <code>GitHub</code>，可以免费搭建个人博客，并享受其强大的功能和灵活的定制性。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>相信想搞博客的人，应该最基本的git，node，github账号应该都会吧，这里就省略了。</p><h1 id="安装和配置Hexo"><a href="#安装和配置Hexo" class="headerlink" title="安装和配置Hexo"></a>安装和配置Hexo</h1><p>全局安装 <code>hexo</code></p><blockquote><p>mac用户记得sudo</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装</span><br>npm install -g hexo-cli<br><span class="hljs-comment"># 查看是否成功</span><br>hexo version<br></code></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>安装 <code>Hexo</code> 完成后，执行下列命令，<code>Hexo</code> 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init &lt;folder&gt; <br><span class="hljs-built_in">cd</span> &lt;folder&gt;<br>npm install<br></code></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── <span class="hljs-built_in">source</span><br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br><br></code></pre></td></tr></table></figure><ul><li><code>_config.yml</code>：站的 配置 信息，您可以在此配置大部分的参数。</li><li><code>package.json</code>：应用程序的信息。<code>EJS</code>, <code>Stylus</code> 和 <code>Markdown renderer</code> 已默认安装。</li><li><code>scaffolds</code>：模版文件夹。当新建文章时，<code>Hexo</code> 会根据 <code>scaffold</code> 来建立文件。</li><li>source：资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。<code>Markdown</code> 和 <code>HTML</code> 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</li><li><code>themes</code>：主题 文件夹。<code>Hexo</code> 会根据主题来生成静态页面。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于useWebsocket的思考</title>
    <link href="/2023/09/01/vueuse/%E5%85%B3%E4%BA%8EuseWebsocket%E7%9A%84bug/"/>
    <url>/2023/09/01/vueuse/%E5%85%B3%E4%BA%8EuseWebsocket%E7%9A%84bug/</url>
    
    <content type="html"><![CDATA[<p>今天来讲讲useWebsocket的bug</p><h1 id="关于vueuse中useWebsocket的问题"><a href="#关于vueuse中useWebsocket的问题" class="headerlink" title="关于vueuse中useWebsocket的问题"></a>关于vueuse中useWebsocket的问题</h1><h2 id="发现bug背景"><a href="#发现bug背景" class="headerlink" title="发现bug背景"></a>发现bug背景</h2><p>由于项目比较复杂，websockt不能一直连着，而且当某个字段变了之后，需要将原来的关闭并且新开一个socket。然后我发现如果url改变了，会有一条socket一直连着，也不能关闭也不能操作。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>经过我的多次测试以及查看源代码，我发现应该是 <code>autoReconnect： true</code>，所以在url改变时他会触发重新链接，但是由于url变了，所以那条socket会一直连着，无法关闭。</p><p>我已经向vueuse提交了issues，不知道anft大神会不会看到我提交的bug并修复，有点小兴奋。</p><p>最后附上issues地址： <a href="https://github.com/vueuse/vueuse/issues/3364">useWebsocket</a></p><h1 id="2024-1-30-最新结论"><a href="#2024-1-30-最新结论" class="headerlink" title="2024.1.30 最新结论"></a>2024.1.30 最新结论</h1><p>在设置 <code>immediate</code>为 <code>false</code>并且 <code>autoReconnect</code>为 <code>true</code>之后，如果url是ref或computed的，在改变之后不会先将之前的ws先关闭再开启新的ws，这就导致这样设置之后ws会越来越多，我提交了pr修复此bug，但至今仍未合并。可以看下我是如何修复的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">watch</span>(urlRef, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (immediate)<br>      <span class="hljs-title function_">open</span>()<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-title function_">close</span>()<br>  &#125;, &#123; <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> &#125;)<br><br></code></pre></td></tr></table></figure><p>原本的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">if</span> (immediate)<br>    <span class="hljs-title function_">watch</span>(urlRef, open, &#123; <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> &#125;)<br></code></pre></td></tr></table></figure><p>附上pr地址： <a href="https://github.com/vueuse/vueuse/pull/3676">useWebsocket</a></p>]]></content>
    
    
    <categories>
      
      <category>vueuse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>vueuse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>useSound问题</title>
    <link href="/2023/09/01/vueuse/useSound%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <url>/2023/09/01/vueuse/useSound%E8%B8%A9%E5%9D%91%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>还记的那天，产品经理给我提了个需求，要我做一个组件。要求也是蛮常规的，就是做一个声音选择的下拉单选框，选中啥放啥声音（<em>这里还有一个，就是需要上上传功能，但后续讨论只需要配置默认声音，提供选择，就没做了。做起来也不麻烦，只需要上传之后，返回一个可下载的链接使用useObjectUrl()钩子</em>）。心想这不so easy分分钟就给你搞定。当然，你觉得一件事很简单的时候，他就越容易出问题。</p><h1 id="问题阐述"><a href="#问题阐述" class="headerlink" title="问题阐述"></a>问题阐述</h1><p>由于我非常喜欢vueuse，所以一接到这个需求的时候，我就想到了vueuse的useSound。既然如此那就开干。</p><ul><li>setup 部分</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> selectValue = ref&lt;<span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>&gt;()<br><span class="hljs-keyword">const</span> &#123; play &#125; = <span class="hljs-title function_">useSound</span>(selectValue)<br></code></pre></td></tr></table></figure><ul><li>template部分</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a-select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selectValue&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>结果我把网页开打一看，好家伙，啥效果都没有，我寻思不可能吧，这么大个库也能出bug?</p><p>让我来瞅瞅哪里出问题了,  先来看看这个函数的ts类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useSound</span>(<span class="hljs-params"><span class="hljs-attr">url</span>: <span class="hljs-title class_">MaybeRef</span>&lt;<span class="hljs-built_in">string</span>&gt;, &#123; volume, playbackRate, soundEnabled, interrupt, autoplay, onload, ...delegated &#125;?: <span class="hljs-title class_">ComposableOptions</span></span>): <span class="hljs-title class_">ReturnedValue</span>;<br></code></pre></td></tr></table></figure><p>嗯….只能传非空的url，然后他的源码并没有对非空url进行处理。我们实际开发者，肯定会遇到空值的情况，所以对我来说这个函数不太能符合我的需求。</p><p>怎么办呢。。。我灵机一动，我把它的源码拿下来自己改改不就行了。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>由于我现在都使用vue3来写，所以就没考虑兼容vue2，需要的童鞋自己使用vue-demi实现下把</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!-- index.<span class="hljs-property">js</span> --&gt;<br><span class="hljs-keyword">import</span> howler <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;howler&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useSound</span>(<span class="hljs-params">url, &#123; volume = <span class="hljs-number">1</span>, playbackRate = <span class="hljs-number">1</span>, soundEnabled = <span class="hljs-literal">true</span>, interrupt = <span class="hljs-literal">false</span>, autoplay = <span class="hljs-literal">false</span>, onload, ...delegated &#125; = &#123;&#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">HowlConstructor</span> = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> isPlaying = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">const</span> duration = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> sound = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">if</span>(<span class="hljs-title function_">unref</span>(url)) &#123;<br>      sound.<span class="hljs-property">value</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HowlConstructor</span>.<span class="hljs-title function_">value</span>(&#123;<br>      <span class="hljs-attr">src</span>: <span class="hljs-title function_">unref</span>(url),<br>      <span class="hljs-attr">volume</span>: <span class="hljs-title function_">unref</span>(volume),<br>      <span class="hljs-attr">rate</span>: <span class="hljs-title function_">unref</span>(playbackRate),<br>      <span class="hljs-attr">onload</span>: handleLoad,<br>      ...delegated<br>    &#125;);<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleLoad</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onload === <span class="hljs-string">&quot;function&quot;</span>)<br>      onload.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>    duration.<span class="hljs-property">value</span> = (duration.<span class="hljs-property">value</span> || sound.<span class="hljs-property">value</span>?.<span class="hljs-title function_">duration</span>() || <span class="hljs-number">0</span>) * <span class="hljs-number">1e3</span>;<br>    <span class="hljs-keyword">if</span> (autoplay === <span class="hljs-literal">true</span>) &#123;<br>      isPlaying.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">watch</span>(<br>    <span class="hljs-function">() =&gt;</span> [<span class="hljs-title function_">unref</span>(url)],<br>    <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">unref</span>(url)) &#123;<br>        sound.<span class="hljs-property">value</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HowlConstructor</span>.<span class="hljs-title function_">value</span>(&#123;<br>          <span class="hljs-attr">src</span>: <span class="hljs-title function_">unref</span>(url),<br>          <span class="hljs-attr">volume</span>: <span class="hljs-title function_">unref</span>(volume),<br>          <span class="hljs-attr">rate</span>: <span class="hljs-title function_">unref</span>(playbackRate),<br>          <span class="hljs-attr">onload</span>: handleLoad,<br>          ...delegated<br>        &#125;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        sound.<span class="hljs-property">value</span> = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span><br>      &#125;<br>    &#125;<br>  );<br>  <span class="hljs-title function_">watch</span>(<br>    <span class="hljs-function">() =&gt;</span> [<span class="hljs-title function_">unref</span>(volume), <span class="hljs-title function_">unref</span>(playbackRate)],<br>    <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (sound.<span class="hljs-property">value</span>) &#123;<br>        sound.<span class="hljs-property">value</span>.<span class="hljs-title function_">volume</span>(<span class="hljs-title function_">unref</span>(volume));<br>        sound.<span class="hljs-property">value</span>.<span class="hljs-title function_">rate</span>(<span class="hljs-title function_">unref</span>(playbackRate));<br>      &#125;<br>    &#125;<br>  );<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">play</span> = (<span class="hljs-params">options</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>      options = &#123;&#125;;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!sound.<span class="hljs-property">value</span> || !soundEnabled &amp;&amp; !options.<span class="hljs-property">forceSoundEnabled</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (interrupt) &#123;<br>      sound.<span class="hljs-property">value</span>.<span class="hljs-title function_">stop</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (options.<span class="hljs-property">playbackRate</span>) &#123;<br>      sound.<span class="hljs-property">value</span>.<span class="hljs-title function_">rate</span>(options.<span class="hljs-property">playbackRate</span>);<br>    &#125;<br>    sound.<span class="hljs-property">value</span>.<span class="hljs-title function_">play</span>(options.<span class="hljs-property">id</span>);<br>    sound.<span class="hljs-property">value</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (sound.<span class="hljs-property">value</span> &amp;&amp; sound.<span class="hljs-property">value</span> &amp;&amp; !sound.<span class="hljs-property">value</span>.<span class="hljs-title function_">playing</span>()) &#123;<br>        isPlaying.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;);<br>    isPlaying.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span>;<br>  &#125;;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">stop</span> = (<span class="hljs-params">id</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (!sound.<span class="hljs-property">value</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    sound.<span class="hljs-property">value</span>.<span class="hljs-title function_">stop</span>(<span class="hljs-keyword">typeof</span> id === <span class="hljs-string">&quot;number&quot;</span> ? id : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>);<br>    isPlaying.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;<br>  &#125;;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">pause</span> = (<span class="hljs-params">id</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (!sound.<span class="hljs-property">value</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    sound.<span class="hljs-property">value</span>.<span class="hljs-title function_">pause</span>(<span class="hljs-keyword">typeof</span> id === <span class="hljs-string">&quot;number&quot;</span> ? id : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>);<br>    isPlaying.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;<br>  &#125;;<br>  <span class="hljs-keyword">const</span> returnedValue = &#123;<br>    play,<br>    sound,<br>    isPlaying,<br>    duration,<br>    pause,<br>    stop<br>  &#125;;<br>  <span class="hljs-keyword">return</span> returnedValue;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&lt;!-- index.<span class="hljs-property">d</span>.<span class="hljs-property">ts</span> --&gt;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">HowlOptions</span>, <span class="hljs-title class_">Howl</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;howler&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Ref</span>, <span class="hljs-title class_">ComputedRef</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">MaybeRef</span>&lt;T&gt; = T | <span class="hljs-title class_">Ref</span>&lt;T&gt; | <span class="hljs-title class_">ComputedRef</span>&lt;T&gt;;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SpriteMap</span> &#123;<br>    [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];<br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ComposableOptions</span> = &#123;<br>    <span class="hljs-attr">volume</span>?: <span class="hljs-title class_">MaybeRef</span>&lt;<span class="hljs-built_in">number</span>&gt;;<br>    <span class="hljs-attr">playbackRate</span>?: <span class="hljs-title class_">MaybeRef</span>&lt;<span class="hljs-built_in">number</span>&gt;;<br>    <span class="hljs-attr">interrupt</span>?: <span class="hljs-built_in">boolean</span>;<br>    <span class="hljs-attr">soundEnabled</span>?: <span class="hljs-built_in">boolean</span>;<br>    <span class="hljs-attr">autoplay</span>?: <span class="hljs-built_in">boolean</span>;<br>    <span class="hljs-attr">sprite</span>?: <span class="hljs-title class_">SpriteMap</span>;<br>    <span class="hljs-attr">onload</span>?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125; &amp; <span class="hljs-title class_">Omit</span>&lt;<span class="hljs-title class_">HowlOptions</span>, <span class="hljs-string">&#x27;src&#x27;</span>&gt;;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PlayOptions</span> &#123;<br>    <span class="hljs-attr">id</span>?: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">forceSoundEnabled</span>?: <span class="hljs-built_in">boolean</span>;<br>    <span class="hljs-attr">playbackRate</span>?: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PlayFunction</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">options</span>?: <span class="hljs-title class_">PlayOptions</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReturnedValue</span> &#123;<br>    <span class="hljs-attr">play</span>: <span class="hljs-title class_">PlayFunction</span>;<br>    <span class="hljs-attr">sound</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-title class_">Howl</span> | <span class="hljs-literal">null</span>&gt;;<br>    <span class="hljs-attr">stop</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">id</span>?: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>    <span class="hljs-attr">pause</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">id</span>?: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>    <span class="hljs-attr">isPlaying</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">boolean</span>&gt;;<br>    <span class="hljs-attr">duration</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>&gt;;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useSound</span>(<span class="hljs-params"><span class="hljs-attr">url</span>: <span class="hljs-title class_">MaybeRef</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>&gt;, &#123; volume, playbackRate, soundEnabled, interrupt, autoplay, onload, ...delegated &#125;?: <span class="hljs-title class_">ComposableOptions</span></span>): <span class="hljs-title class_">ReturnedValue</span>;<br><br><span class="hljs-keyword">export</span> &#123; useSound &#125;;<br><br></code></pre></td></tr></table></figure><p>把这两段代码自己封装下hook，就可以在项目中使用啦，亲测好用</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然有些需求看上去简单，实现起来也简单，但里面还是有坑的，必须小心别踩坑了。</p><p>最后想感叹句，站在巨人的肩膀上，真的舒服啊。</p><p>代码参考： <a href="https://github.com/vueuse/sound">vueuse  useSound</a></p>]]></content>
    
    
    <categories>
      
      <category>vueuse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>vueuse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>arco-design的tabs组件问题</title>
    <link href="/2023/09/01/arcoDesign/ATabs%E6%98%BE%E7%A4%BAcontent/"/>
    <url>/2023/09/01/arcoDesign/ATabs%E6%98%BE%E7%A4%BAcontent/</url>
    
    <content type="html"><![CDATA[<h1 id="使用ATabs进行切换"><a href="#使用ATabs进行切换" class="headerlink" title="使用ATabs进行切换"></a>使用ATabs进行切换</h1><p>问题：a-tabs 使用 v-model:active-key 绑定默认要展示的 tab 使用 tabs-click 出发切换 tab 不要使用组件提供的属性切换，会导致内容切换时不重新渲染</p><p>解决：click 时修改 activeKey 值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a-tabs</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;activeKey&quot;</span> @<span class="hljs-attr">tab-click</span>=<span class="hljs-string">&quot;click&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a-tab-pane</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;activeKey == 1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">a-tab-pane</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a-tab-pane</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;activeKey == 2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">a-tab-pane</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">a-tabs</span>&gt;</span><br></code></pre></td></tr></table></figure><p>后续发现其实ATab用于切换  <strong>content的部分使用component切换最好</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a-tabs</span> <span class="hljs-attr">v-model:activeKey</span>=<span class="hljs-string">&quot;activeKey&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;getComponent&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>arcoDesign</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>arcoDesign</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
